#!/usr/bin/env node
// Habilita modo debug para verbose em tempo real
let debugEnabled = false;

/*
 * FazAI - Orquestrador Inteligente de Automa√ß√£o
 * Autor: Roger Luft
 * Licen√ßa: Creative Commons Attribution 4.0 International (CC BY 4.0)
 * https://creativecommons.org/licenses/by/4.0/
 */

/**
 * FazAI - Orquestrador Inteligente de Automa√ß√£o
 * CLI (Command Line Interface)
 * 
 * Este arquivo implementa a interface de linha de comando do FazAI, respons√°vel por:
 * - Receber comandos do usu√°rio
 * - Enviar comandos para o daemon
 * - Exibir resultados para o usu√°rio
 */

// Verifica√ß√£o de depend√™ncias
let axios;
try {
  axios = require('axios');
} catch (err) {
  console.error('\x1b[31m[ERRO] M√≥dulo axios n√£o encontrado. Por favor, instale-o com:\x1b[0m');
  console.error('\x1b[33m  npm install -g axios\x1b[0m');
  console.error('\x1b[33m  ou\x1b[0m');
  console.error('\x1b[33m  cd /opt/fazai && npm install axios\x1b[0m');
  process.exit(1);
}

// Verifica√ß√£o de outras depend√™ncias cr√≠ticas
let fs, path, readline, spawn;
try {
  fs = require('fs');
  path = require('path');
  readline = require('readline');
  const childProcess = require('child_process');
  spawn = childProcess.spawn;
} catch (err) {
  console.error('\x1b[31m[ERRO] M√≥dulo Node.js b√°sico n√£o encontrado: ' + err.message + '\x1b[0m');
  console.error('\x1b[33m  Verifique sua instala√ß√£o do Node.js\x1b[0m');
  process.exit(1);
}

// Verifica√ß√£o do arquivo principal
const mainJsPath = '/opt/fazai/lib/main.js';
if (!fs.existsSync(mainJsPath)) {
  console.error('\x1b[31m[ERRO] Arquivo principal n√£o encontrado: ' + mainJsPath + '\x1b[0m');
  console.error('\x1b[33m  Verifique se o FazAI est√° instalado corretamente\x1b[0m');
  process.exit(1);
}

// Fun√ß√£o para executar agente inteligente
async function runAgent(objective) {
  try {
    console.log('\x1b[36mü§ñ FazAI Agent iniciando...\x1b[0m');
    console.log('\x1b[33mObjetivo:\x1b[0m', objective);
    console.log('');

    // Criar sess√£o
    const sessionResponse = await axios.post(`${API_URL}/agent/sessions`, {});
    if (!sessionResponse.data.ok) {
      throw new Error('Falha ao criar sess√£o');
    }
    
    const sessionId = sessionResponse.data.session_id;
    console.log('\x1b[32m‚úì Sess√£o criada:\x1b[0m', sessionId);

    // Configurar handler de interrup√ß√£o
    process.on('SIGINT', async () => {
      console.log('\n\x1b[33müõë Interrompendo agente...\x1b[0m');
      try {
        await axios.post(`${API_URL}/agent/abort`, { session_id: sessionId });
      } catch (e) {
        // Ignorar erros de abort
      }
      process.exit(130);
    });

    // Iniciar stream SSE
    const response = await axios.post(`${API_URL}/agent/generate`, {
      session_id: sessionId,
      objective: objective,
      history: []
    }, {
      responseType: 'stream',
      headers: {
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache'
      }
    });

    let buffer = '';
    
    response.data.on('data', (chunk) => {
      buffer += chunk.toString();
      
      // Processar eventos SSE
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const event = JSON.parse(line.slice(6));
            handleAgentEvent(event);
          } catch (e) {
            // Ignorar linhas que n√£o s√£o JSON v√°lido
          }
        }
      }
    });

    response.data.on('end', () => {
      console.log('\n\x1b[32m‚úÖ Agente conclu√≠do\x1b[0m');
    });

    response.data.on('error', (error) => {
      console.error('\n\x1b[31m‚ùå Erro no stream:\x1b[0m', error.message);
    });

  } catch (error) {
    console.error('\x1b[31m‚ùå Erro ao executar agente:\x1b[0m', error.message);
    process.exit(1);
  }
}

// Handler de eventos do agente
function handleAgentEvent(event) {
  switch (event.type) {
    case 'token':
      process.stdout.write(event.text);
      break;
      
    case 'plan':
      console.log('\n\x1b[35müìã Plano:\x1b[0m', event.steps.join(' ‚Üí '));
      break;
      
    case 'action':
      console.log('\n\x1b[34m‚ö° A√ß√£o:\x1b[0m', event.action, event.command || event.name || '');
      break;
      
    case 'exec_log':
      process.stdout.write(event.chunk);
      break;
      
    case 'observe':
      console.log('\n\x1b[36müëÅÔ∏è  Observa√ß√£o:\x1b[0m', event.note);
      break;
      
    case 'ask':
      console.log('\n\x1b[33m‚ùì Pergunta:\x1b[0m', event.question);
      if (event.options && event.options.length > 0) {
        console.log('\x1b[33mOp√ß√µes:\x1b[0m');
        event.options.forEach((option, i) => {
          console.log(`  ${i + 1}. ${option}`);
        });
      }
      // TODO: Implementar intera√ß√£o com usu√°rio
      break;
      
    case 'done':
      console.log('\n\x1b[32m‚úÖ Itera√ß√£o conclu√≠da\x1b[0m');
      if (event.result) {
        console.log('\x1b[32mResultado:\x1b[0m', event.result);
      }
      break;
      
    case 'error':
      console.error('\n\x1b[31m‚ùå Erro:\x1b[0m', event.message);
      break;
      
    default:
      // Ignorar eventos desconhecidos
      break;
  }
}

// Configura√ß√£o do cliente
const API_URL = process.env.FAZAI_API_URL || 'http://localhost:3120';
const LOG_FILE = '/var/log/fazai/fazai.log';
const STREAM_URL = `${API_URL}/command/stream`;

// Cores para sa√≠da no terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  underscore: '\x1b[4m',
  blink: '\x1b[5m',
  reverse: '\x1b[7m',
  hidden: '\x1b[8m',
  
  fg: {
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m'
  },
  
  bg: {
    black: '\x1b[40m',
    red: '\x1b[41m',
    green: '\x1b[42m',
    yellow: '\x1b[43m',
    blue: '\x1b[44m',
    magenta: '\x1b[45m',
    cyan: '\x1b[46m',
    white: '\x1b[47m'
  }
};
/**
 * Exibe mensagem de debug se modo debug estiver ativo
 * @param {string} message - Mensagem de debug
 */
function printDebug(message) {
  if (debugEnabled) console.log(`${colors.fg.magenta}[DEBUG] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem de erro formatada
 * @param {string} message - Mensagem de erro
 */
function printError(message) {
  console.error(`${colors.fg.red}[ERRO] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem de sucesso formatada
 * @param {string} message - Mensagem de sucesso
 */
function printSuccess(message) {
  console.log(`${colors.fg.green}[SUCESSO] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem informativa formatada
 * @param {string} message - Mensagem informativa
 */
function printInfo(message) {
  console.log(`${colors.fg.cyan}[INFO] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem de aviso formatada
 * @param {string} message - Mensagem de aviso
 */
function printWarning(message) {
  console.log(`${colors.fg.yellow}[AVISO] ${message}${colors.reset}`);
}

/**
 * Envia comando para o daemon
 * @param {string} command - Comando a ser enviado
 * @returns {Promise<object>} - Resposta do daemon
 */
async function sendCommand(command) {
  // Debug: mostra detalhes da requisi√ß√£o
  printDebug(`[sendCommand] POST ${API_URL}/command payload: ${JSON.stringify({command})}`);
  try {
    printInfo(`Conectando ao daemon em ${API_URL}...`);
    const response = await axios.post(`${API_URL}/command`, { command }, {
      timeout: 30000 // 30 segundos de timeout
    });
    // Debug: mostra detalhes da resposta HTTP
    printDebug(`[sendCommand] HTTP ${response.status} ${response.statusText}`);
    printDebug(`[sendCommand] response.data: ${JSON.stringify(response.data)}`);
    
    if (!response.data.success) {
      if (response.data.error) {
        throw new Error(response.data.error);
      } else if (response.data.interpretation) {
        printWarning(`O comando foi interpretado, mas a execu√ß√£o falhou: ${response.data.interpretation}`);
        if (response.data.details) {
          printError(`Detalhes do erro: ${response.data.details}`);
        }
        return response.data;
      } else {
        throw new Error('Resposta do servidor indica falha, mas sem detalhes espec√≠ficos');
      }
    }
    
    return response.data;
  } catch (err) {
    if (err.response) {
      // Erro com resposta do servidor
      const errorData = err.response.data;
      if (errorData && errorData.error) {
        throw new Error(`Erro do servidor: ${errorData.error}`);
      } else if (errorData && errorData.details) {
        throw new Error(`Erro do servidor: ${errorData.details}`);
      } else {
        throw new Error(`Erro do servidor: ${err.response.status} ${err.response.statusText}`);
      }
    } else if (err.request) {
      // Erro sem resposta (problema de conex√£o)
      throw new Error(`N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o em ${API_URL}.`);
    } else {
      // Erro na configura√ß√£o da requisi√ß√£o
      throw new Error(`Erro ao enviar comando: ${err.message}`);
    }
  }
}

/**
 * Conecta ao endpoint SSE e imprime eventos em tempo real
 * @param {{command: string, mcps?: boolean, cwd?: string, question?: boolean}} body
 */
async function streamToConsole(body) {
  const http = require('http');
  const https = require('https');
  const url = require('url');
  const parsed = url.parse(STREAM_URL);
  const isHttps = parsed.protocol === 'https:';
  const lib = isHttps ? https : http;

  const payload = JSON.stringify(body);
  const options = {
    method: 'POST',
    hostname: parsed.hostname,
    port: parsed.port || (isHttps ? 443 : 80),
    path: parsed.path,
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(payload)
    }
  };

  printInfo(`Conectando (SSE) a ${STREAM_URL}...`);
  await new Promise((resolve, reject) => {
    const req = lib.request(options, (res) => {
      if (res.statusCode < 200 || res.statusCode >= 300) {
        reject(new Error(`Status HTTP ${res.statusCode}`));
        return;
      }

      res.setEncoding('utf8');
      let buffer = '';

      const flushBuffer = () => {
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          if (line.startsWith('event:')) {
            // armazenado at√© pr√≥ximo data
            streamToConsole._currentEvent = line.slice(6).trim();
          } else if (line.startsWith('data:')) {
            const ev = (streamToConsole._currentEvent || 'message');
            const raw = line.slice(5).trim();
            let data;
            try { data = JSON.parse(raw); } catch { data = { text: raw }; }
            renderSseEvent(ev, data);
          }
        }
      };

      res.on('data', (chunk) => { buffer += chunk; flushBuffer(); });
      res.on('end', () => { flushBuffer(); resolve(); });
    });
    req.on('error', reject);
    req.write(payload);
    req.end();
  });
}

function renderSseEvent(event, data) {
  switch (event) {
    case 'received':
      printInfo(`Recebido pelo daemon: "${data.command}" (mcps=${!!data.mcps})`);
      break;
    case 'phase':
      printInfo(`Fase: ${data.phase}`);
      break;
    case 'interpretation':
      if (data.interpretation) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Interpreta√ß√£o:${colors.reset} ${data.interpretation}\n`);
      }
      break;
    case 'stdout':
      process.stdout.write(data.chunk);
      break;
    case 'stderr':
      process.stderr.write(`${colors.fg.yellow}${data.chunk}${colors.reset}`);
      break;
    case 'steps':
      if (Array.isArray(data.steps)) {
        printInfo(`MCPS: ${data.steps.length} passos gerados`);
      }
      break;
    case 'step_start':
      console.log(`\n${colors.bright}${colors.fg.cyan}Iniciando passo ${data.index + 1}:${colors.reset} ${data.command}`);
      break;
    case 'step_stdout':
      process.stdout.write(data.chunk);
      break;
    case 'step_stderr':
      process.stderr.write(`${colors.fg.yellow}${data.chunk}${colors.reset}`);
      break;
    case 'step_end':
      const status = data.code === 0 ? `${colors.fg.green}OK${colors.reset}` : `${colors.fg.red}FAIL (code ${data.code})${colors.reset}`;
      console.log(`\n${colors.bright}Passo ${data.index + 1} finalizado:${colors.reset} ${status}`);
      break;
    case 'plan_results':
      printInfo('Plano arquitetado executado.');
      break;
    case 'interactive':
      printWarning('Intera√ß√£o requerida pelo plano. Abra a interface apropriada.');
      break;
    case 'answer':
      console.log(`\n${colors.bright}${colors.fg.yellow}Resposta:${colors.reset}\n${data.answer}\n`);
      break;
    case 'exit':
      // apenas informativo
      break;
    case 'done':
      printSuccess(`Conclu√≠do (success=${data.success})`);
      break;
    case 'error':
      printError(data.message || 'Erro');
      break;
    default:
      if (data?.text) console.log(data.text);
  }
}

/**
 * Envia comando para o daemon no modo MCPS
 * @param {string} command - Comando a ser enviado
 * @returns {Promise<object>} - Resposta do daemon
 */
async function sendCommandMcps(command) {
  // Debug: mostra detalhes da requisi√ß√£o MCPS
  printDebug(`[sendCommandMcps] POST ${API_URL}/command payload: ${JSON.stringify({command, mcps: true})}`);
  try {
    printInfo(`Conectando ao daemon em ${API_URL} (MCPS)...`);
    const response = await axios.post(`${API_URL}/command`, { command, mcps: true }, {
      timeout: 30000 // 30 segundos de timeout
    });
    // Debug: mostra detalhes da resposta MCPS
    printDebug(`[sendCommandMcps] HTTP ${response.status} ${response.statusText}`);
    printDebug(`[sendCommandMcps] response.data: ${JSON.stringify(response.data)}`);

    if (!response.data.success) {
      if (response.data.error) {
        throw new Error(response.data.error);
      } else if (response.data.interpretation) {
        printWarning(`O comando foi interpretado, mas a execu√ß√£o falhou: ${response.data.interpretation}`);
        if (response.data.details) {
          printError(`Detalhes do erro: ${response.data.details}`);
        }
        return response.data;
      } else {
        throw new Error('Resposta do servidor indica falha, mas sem detalhes espec√≠ficos');
      }
    }

    return response.data;
  } catch (err) {
    if (err.response) {
      const errorData = err.response.data;
      if (errorData && errorData.error) {
        throw new Error(`Erro do servidor: ${errorData.error}`);
      } else if (errorData && errorData.details) {
        throw new Error(`Erro do servidor: ${errorData.details}`);
      } else {
        throw new Error(`Erro do servidor: ${err.response.status} ${err.response.statusText}`);
      }
    } else if (err.request) {
      throw new Error(`N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o em ${API_URL}.`);
    } else {
      throw new Error(`Erro ao enviar comando: ${err.message}`);
    }
  }
}

/**
 * Solicita recarga de plugins e m√≥dulos
 * @returns {Promise<object>} - Resposta do daemon
 */
async function reloadModules() {
  try {
    const response = await axios.post(`${API_URL}/reload`);
    return response.data;
  } catch (err) {
    if (err.response) {
      throw new Error(`Erro do servidor: ${err.response.data.error || 'Desconhecido'}`);
    } else if (err.request) {
      throw new Error('N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o.');
    } else {
      throw new Error(`Erro ao recarregar m√≥dulos: ${err.message}`);
    }
  }
}

/**
 * Executa comando systemctl para o servi√ßo FazAI
 * @param {string} action - start | stop | restart | status
 */
function systemctlCommand(action) {
  const { spawnSync } = require('child_process');
  printInfo(`Executando systemctl ${action} fazai...`);
  const result = spawnSync('systemctl', [action, 'fazai'], { encoding: 'utf8' });
  if (result.stdout) console.log(result.stdout.trim());
  if (result.stderr) console.error(result.stderr.trim());
  return result.status === 0;
}

/**
 * Exibe as √∫ltimas linhas do arquivo de log
 * @param {number} lines - N√∫mero de linhas a exibir
 */
function showLogs(lines = 10) {
  try {
    if (!fs.existsSync(LOG_FILE)) {
      printError(`Arquivo de log n√£o encontrado: ${LOG_FILE}`);
      return;
    }
    
    const logContent = fs.readFileSync(LOG_FILE, 'utf8');
    const logLines = logContent.split('\n').filter(line => line.trim() !== '');
    
    const lastLines = logLines.slice(-lines);
    
    console.log(`\n${colors.bright}${colors.fg.yellow}=== √öltimas ${lines} entradas de log ===${colors.reset}\n`);
    
    lastLines.forEach(line => {
      try {
        const logEntry = JSON.parse(line);
        const timestamp = new Date(logEntry.timestamp).toLocaleString();
        const level = logEntry.level.toUpperCase();
        const message = logEntry.message;
        
        let levelColor = colors.fg.white;
        switch (level) {
          case 'ERROR':
            levelColor = colors.fg.red;
            break;
          case 'WARN':
            levelColor = colors.fg.yellow;
            break;
          case 'INFO':
            levelColor = colors.fg.green;
            break;
          case 'DEBUG':
            levelColor = colors.fg.cyan;
            break;
        }
        
        console.log(`${colors.dim}[${timestamp}]${colors.reset} ${levelColor}${level}${colors.reset}: ${message}`);
      } catch (err) {
        console.log(line);
      }
    });
    
    console.log(`\n${colors.bright}${colors.fg.yellow}=== Fim dos logs ===${colors.reset}\n`);
  } catch (err) {
    printError(`Erro ao ler logs: ${err.message}`);
  }
}

/**
 * Limpa o arquivo de log
 */
async function clearLogs() {
  try {
    printInfo('Limpando logs do FazAI...');
    
    const response = await axios.post(`${API_URL}/logs/clear`);
    
    if (response.data.success) {
      printSuccess('Logs limpos com sucesso!');
      if (response.data.backup) {
        printInfo(`Backup criado em: ${response.data.backup}`);
      }
    } else {
      printError(`Erro ao limpar logs: ${response.data.error}`);
    }
  } catch (err) {
    if (err.response) {
      printError(`Erro do servidor: ${err.response.data.error || 'Desconhecido'}`);
    } else if (err.request) {
      printError('N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o.');
    } else {
      printError(`Erro ao limpar logs: ${err.message}`);
    }
  }
}

/**
 * Fun√ß√£o principal
 */
async function main() {
  // Obt√©m argumentos e normaliza flags em qualquer posi√ß√£o
  const rawArgs = process.argv.slice(2);
  let args = [];
  let streamEnabled = false;
  let questionMode = false;
  rawArgs.forEach((arg) => {
    if (arg === '-d' || arg === '--debug') {
      debugEnabled = true;
    } else if (arg === '--stream' || arg === '-s') {
      streamEnabled = true;
    } else if (arg === '-q' || arg === '--question') {
      questionMode = true;
    } else {
      args.push(arg);
    }
  });
  if (debugEnabled) printInfo('Modo debug ativado');

  // Comandos especiais
  if (args.length === 0) {
    printError('Nenhum comando fornecido. Use "fazai ajuda" para ver os comandos dispon√≠veis.');
    process.exit(1);
  }
  
  if (args[0] === 'ajuda' || args[0] === 'help' || args[0] === '--help') {
    console.log(`
${colors.bright}${colors.fg.cyan}FazAI v1.42.2${colors.reset}

${colors.bright}Compat√≠vel com:${colors.reset}
  ‚Ä¢ Debian/Ubuntu
  ‚Ä¢ Fedora/RedHat/CentOS
  ‚Ä¢ WSL (Debian/Ubuntu)

${colors.bright}Uso:${colors.reset}
  fazai [-d|--debug] [--stream|-s] [-q] <comando>
  fazai agent <objetivo>

${colors.bright}Comandos de Sistema:${colors.reset}
  ajuda, help, --help         Exibe esta mensagem de ajuda
  manual                      Abre o manual completo de utiliza√ß√£o
  -d, --debug                 Ativa modo debug com verbose em tempo real
  versao, version, -v         Exibe a vers√£o do FazAI
  -q, --question              Pergunta direta (sem executar comandos)
  check-deps, verificar-deps  Verifica depend√™ncias e instala√ß√£o do sistema

${colors.bright}Comandos de Servi√ßo:${colors.reset}
  start                       Inicia o servi√ßo FazAI
  stop                        Para o servi√ßo FazAI
  restart                     Reinicia o servi√ßo FazAI
  status                      Mostra o status do servi√ßo FazAI
  reload                      Recarrega plugins e m√≥dulos

${colors.bright}Comandos de Logs:${colors.reset}
  logs [n]                    Exibe as √∫ltimas n entradas de log (padr√£o: 10)
  limpar-logs, clear-logs     Limpa o arquivo de log (cria backup)
  web                         Abre a interface web de gerenciamento

${colors.bright}Comandos de Sistema R√°pido:${colors.reset}
  kernel                      Exibe vers√£o do kernel (uname -r)
  sistema                     Exibe informa√ß√µes do sistema (uname -a)
  memoria                     Exibe uso de mem√≥ria (free -h)
  disco                       Exibe uso de disco (df -h)
  processos                   Lista processos (ps aux)
  rede                        Exibe interfaces de rede (ip a)
  data                        Mostra data e hora (date)
  uptime                      Tempo de atividade (uptime)

${colors.bright}Comandos de Visualiza√ß√£o:${colors.reset}
  html <tipo> [graf]          Gera gr√°fico HTML (tipo: memoria, disco, processos)
  tui                         Abre o dashboard TUI (ncurses)
  interactive                 Abre sess√£o interativa (WebSocket PTY)
  complex -g <objetivo> [--web] Executa fluxo complexo multi-etapas

${colors.bright}Comandos de Configura√ß√£o:${colors.reset}
  config                      Abre ferramenta de configura√ß√£o interativa
  cache                       Mostra status do cache de IA
  cache-clear                 Limpa o cache de IA

${colors.bright}Comandos de Pesquisa:${colors.reset}
  -q, --question              Pergunta direta (IA)
  -w, --web                   For√ßa pesquisa web (tool web_search)
  complex -g <objetivo>       Objetivo de alto n√≠vel; usa /complex_flow

${colors.bright}Modo Agent (Agente Inteligente):${colors.reset}
  agent <objetivo>            Exemplo: fazai agent "configurar servidor de email relay"
                              Executa agente inteligente com fluxo iterativo

${colors.bright}Modo MCPS (Planejamento Passo a Passo):${colors.reset}
  mcps <tarefa>               Exemplo: fazai mcps atualizar o sistema
  mcps --stream <tarefa>      Executa MCPS com sa√≠da em tempo real

${colors.bright}Provedores de IA Suportados:${colors.reset}
  ‚Ä¢ OpenRouter (padr√£o)       - M√∫ltiplos modelos via OpenRouter
  ‚Ä¢ OpenAI                    - GPT-4, GPT-3.5-turbo
  ‚Ä¢ Anthropic (Claude)        - Claude 3 Opus, Sonnet, Haiku
  ‚Ä¢ Google Gemini             - Gemini Pro, Pro Vision
  ‚Ä¢ OpenRouter                - Gateway multi-modelos
  ‚Ä¢ Ollama                    - Modelos locais (llama3.2, mixtral, etc.)

${colors.bright}Sistema de Fallback:${colors.reset}
  O FazAI automaticamente tenta o pr√≥ximo provedor em caso de falha:
  Gemma (local) ‚Üí Llama server ‚Üí OpenRouter ‚Üí OpenAI ‚Üí Anthropic ‚Üí Gemini ‚Üí Ollama

${colors.bright}Exemplo de instala√ß√£o Fedora:${colors.reset}
  sudo dnf install -y nodejs npm python3 python3-pip gcc dialog
  sudo ./install.sh

${colors.bright}Exemplos de Uso:${colors.reset}
  fazai mostra os processos em execucao
  fazai cria um usuario com nome teste com a senha teste321 no grupo printers
  fazai instale os modulos mod_security do apache
  fazai altere a porta do ssh de 22 para 31052
  fazai agent "configurar servidor de email relay com antispam"
  fazai mcps atualizar sistema
  fazai config                 # Configurar provedores de IA
  fazai cache                  # Verificar status do cache
  suricata_setup               # Instala/configura Suricata
  modsecurity_setup            # Instala/configura ModSecurity
  crowdsec_setup               # Instala/configura CrowdSec
  spamexperts                  # A√ß√µes em SpamExperts
  cloudflare                   # A√ß√µes na API Cloudflare

${colors.bright}Para mais informa√ß√µes:${colors.reset}
  ‚Ä¢ Documenta√ß√£o: README.md, USAGE.md
  ‚Ä¢ Logs: /var/log/fazai/fazai.log
  ‚Ä¢ Configura√ß√£o: /etc/fazai/fazai.conf
  ‚Ä¢ GitHub: https://github.com/RLuf/FazAI
    `);
    process.exit(0);
  }
  
  if (args[0] === 'manual') {
    const manualPath = '/opt/fazai/MANUAL_COMPLETO.md';
    if (fs.existsSync(manualPath)) {
      const { exec } = require('child_process');
      printInfo('Abrindo manual completo do FazAI...');
      
      // Tenta abrir com diferentes visualizadores
      const viewers = ['xdg-open', 'open', 'cat'];
      let viewerFound = false;
      
      for (const viewer of viewers) {
        if (viewer === 'cat') {
          exec(`cat "${manualPath}"`, (error, stdout, stderr) => {
            if (error) {
              printError(`Erro ao exibir manual: ${error.message}`);
              process.exit(1);
            }
            console.log(stdout);
            process.exit(0);
          });
          viewerFound = true;
          break;
        } else {
          exec(`which ${viewer}`, (error) => {
            if (!error) {
              exec(`${viewer} "${manualPath}"`, (error) => {
                if (error) {
                  printError(`Erro ao abrir manual: ${error.message}`);
                  process.exit(1);
                }
                printSuccess('Manual aberto com sucesso!');
                process.exit(0);
              });
              viewerFound = true;
            }
          });
          if (viewerFound) break;
        }
      }
      
      if (!viewerFound) {
        printError('Nenhum visualizador encontrado. Use: cat /opt/fazai/MANUAL_COMPLETO.md');
        process.exit(1);
      }
    } else {
      printError('Manual n√£o encontrado. Verifique se o arquivo MANUAL_COMPLETO.md est√° em /opt/fazai/');
      process.exit(1);
    }
  }
  
  if (args[0] === 'logs') {
    const lines = args[1] ? parseInt(args[1], 10) : 10;
    showLogs(isNaN(lines) ? 10 : lines);
    process.exit(0);
  }
  
  if (args[0] === 'limpar-logs' || args[0] === 'clear-logs') {
    clearLogs();
    process.exit(0);
  }
  
  if (args[0] === 'reload') {
    try {
      const result = await reloadModules();
      printSuccess('Plugins e m√≥dulos recarregados com sucesso.');
      process.exit(0);
    } catch (err) {
      printError(err.message);
      process.exit(1);
    }
  }
  
  if (args[0] === 'versao' || args[0] === 'version' || args[0] === '--version' || args[0] === '-v') {
    console.log('FazAI v1.42.2');
    process.exit(0);
  }

  if (['start', 'stop', 'restart', 'status'].includes(args[0])) {
    const ok = systemctlCommand(args[0]);
    process.exit(ok ? 0 : 1);
  }

  // Comandos de cache
  if (args[0] === 'cache') {
    try {
      const response = await axios.get(`${API_URL}/cache`);
      console.log(`\n${colors.bright}${colors.fg.cyan}=== Status do Cache ===${colors.reset}`);
      console.log(`Tamanho atual: ${response.data.size}/${response.data.maxSize} entradas`);
      console.log(`TTL: ${response.data.ttl} segundos`);
      console.log(`Hit rate estimado: ${response.data.size > 0 ? 'Ativo' : 'Vazio'}`);
      console.log(`${colors.bright}${colors.fg.cyan}=====================${colors.reset}\n`);
      process.exit(0);
    } catch (err) {
      printError(`Erro ao verificar cache: ${err.message}`);
      process.exit(1);
    }
  }

  if (args[0] === 'cache-clear') {
    try {
      const response = await axios.delete(`${API_URL}/cache`);
      printSuccess('Cache limpo com sucesso!');
      process.exit(0);
    } catch (err) {
      printError(`Erro ao limpar cache: ${err.message}`);
      process.exit(1);
    }
  }

  // Comando de configura√ß√£o
  if (args[0] === 'config') {
    const config_tool = '/opt/fazai/tools/fazai-config.js';
    
    if (!fs.existsSync(config_tool)) {
      printError('Ferramenta de configura√ß√£o n√£o encontrada');
      process.exit(1);
    }

    const { exec } = require('child_process');
    printInfo('Iniciando ferramenta de configura√ß√£o...');
    
    exec(`node ${config_tool}`, (error, stdout, stderr) => {
      if (error) {
        printError(`Erro ao executar ferramenta de configura√ß√£o: ${error.message}`);
        process.exit(1);
      }
      if (stderr) {
        console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
      }
      console.log(`${stdout}`);
      process.exit(0);
    });
  }
  
  // Comandos b√°sicos do sistema que podem ser executados diretamente
  const basicCommands = {
    'kernel': 'uname -r',
    'sistema': 'uname -a',
    'memoria': 'free -h',
    'disco': 'df -h',
    'processos': 'ps aux',
    'rede': 'ip a',
    'data': 'date',
    'uptime': 'uptime',
    'html': 'fazai_html_v1.sh',  // Adiciona comando html como invoca√ß√£o direta
    'web': 'fazai_web.sh',       // Adiciona comando web para interface web
    'tui': 'fazai_tui.sh'        // Adiciona comando tui para dashboard TUI
  };
  
  if (basicCommands[args[0]] || args[0] === 'interactive' || args[0] === 'doctor' || args[0] === 'complex') {
    try {
      // Se o comando for 'html', executa o script com par√¢metros
      if (args[0] === 'html') {
        const script_path = '/opt/fazai/tools/fazai_html_v1.sh';
        const data_type = args[1] || 'memoria';
        const chart_type = args[2] || 'bar';
        
        // Executa o script de gera√ß√£o HTML
        const { exec } = require('child_process');
        printInfo(`Gerando visualiza√ß√£o HTML para ${data_type} com gr√°fico ${chart_type}`);
        
        exec(`chmod +x ${script_path} && ${script_path} ${data_type} ${chart_type}`, (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar script HTML: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}Resultado:${colors.reset}\n${stdout}\n`);
          process.exit(0);
        });
      } else if (args[0] === 'web') {
        // Se o comando for 'web', executa o script da interface web
        const script_path = '/opt/fazai/tools/fazai_web.sh';
        
        const { exec } = require('child_process');
        printInfo('Iniciando interface web do FazAI...');
        
        exec(`chmod +x ${script_path} && ${script_path}`, (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar interface web: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}${stdout}${colors.reset}\n`);
          process.exit(0);
        });
      } else if (args[0] === 'tui') {
        // Se o comando for 'tui', executa o dashboard TUI
        const script_path = '/opt/fazai/tools/fazai-tui.sh';
        
        const { exec } = require('child_process');
        printInfo('Iniciando dashboard TUI do FazAI...');
        
        exec(`chmod +x ${script_path} && ${script_path}`, (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar dashboard TUI: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}${stdout}${colors.reset}\n`);
          process.exit(0);
        });
      } else if (args[0] === 'interactive') {
        // Novo modo: agente. Use --pty para o shell interativo antigo
        const usePty = args.includes('--pty');
        const WebSocket = require('ws');
        if (usePty) {
          const wsUrl = (process.env.FAZAI_WS_URL || API_URL.replace('http', 'ws')) + '/ws/interactive';
          printInfo(`Conectando WS PTY: ${wsUrl}`);
          const ws = new WebSocket(wsUrl);
          ws.on('open', () => {
            printInfo('Sess√£o PTY aberta. Ctrl+C para sair.');
            if (process.stdin.setRawMode) process.stdin.setRawMode(true);
            process.stdin.resume();
            process.stdin.on('data', (chunk) => {
              if (chunk.length === 1 && chunk[0] === 3) { try { ws.close(); } catch(_) {}; process.exit(0); }
              ws.send(JSON.stringify({ type: 'stdin', data: chunk.toString('utf8') }));
            });
          });
          ws.on('message', (msg) => {
            try { const m = JSON.parse(msg.toString()); if (m.type === 'stdout' && m.data) process.stdout.write(m.data); } catch(_) {}
          });
          ws.on('close', () => { printInfo('Sess√£o encerrada'); process.exit(0); });
          ws.on('error', (e) => { printError(`WS erro: ${e.message}`); process.exit(1); });
          return;
        }
        // Agente
        const wsUrl = (process.env.FAZAI_WS_URL || API_URL.replace('http', 'ws')) + '/ws/agent';
        printInfo(`Conectando WS Agente: ${wsUrl}`);
        const ws = new WebSocket(wsUrl);
        const goal = args.slice(1).join(' ').trim();
        ws.on('open', () => {
          printInfo('Agente iniciado. Digite para enviar instru√ß√µes. Ctrl+C para sair.');
          ws.send(JSON.stringify({ type: 'start', goal }));
          const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
          rl.on('line', (line) => {
            if (line.trim().toLowerCase() === 'exit') { try { ws.close(); } catch(_) {}; process.exit(0); }
            ws.send(JSON.stringify({ type: 'user', text: line }));
          });
        });
        ws.on('message', (msg) => {
          try {
            const m = JSON.parse(msg.toString());
            switch (m.type) {
              case 'state': printInfo(`${m.message || ''} ${m.goal?`goal=${m.goal}`:''}`.trim()); break;
              case 'thought': console.log(`${colors.fg.cyan}Pensamento:${colors.reset} ${m.rationale||''}`); break;
              case 'ask': console.log(`${colors.fg.yellow}Pergunta:${colors.reset} ${m.prompt}`); break;
              case 'confirm_needed': console.log(`${colors.fg.yellow}Confirmar:${colors.reset} ${m.command} (digite: sim/n√£o)`); break;
              case 'step_start': console.log(`${colors.fg.cyan}Executando:${colors.reset} ${m.kind==='shell'?m.command:`tool ${m.tool}`}`); break;
              case 'stdout': process.stdout.write(m.chunk); break;
              case 'stderr': process.stderr.write(`${colors.fg.yellow}${m.chunk}${colors.reset}`); break;
              case 'step_end': console.log(`${colors.fg.cyan}Fim:${colors.reset} ${m.kind} ${m.code!==undefined?('code='+m.code):''}`); break;
              case 'result': console.log(`${colors.fg.green}Resultado:${colors.reset} ${typeof m.output==='string'?m.output:JSON.stringify(m.output,null,2)}`); break;
              case 'error': printError(m.message); break;
              case 'done': printSuccess(m.message||'Conclu√≠do'); process.exit(0);
            }
          } catch(_) {}
        });
        ws.on('close', () => { printInfo('Sess√£o encerrada'); process.exit(0); });
        ws.on('error', (e) => { printError(`WS erro: ${e.message}`); process.exit(1); });
        return;
      } else if (args[0] === 'complex') {
        // Encaminha um objetivo de alto n√≠vel para o daemon executar /complex_flow
        const axios = require('axios');
        const goalIdx = args.indexOf('-g') !== -1 ? args.indexOf('-g') : args.indexOf('--goal');
        const allowWeb = args.includes('-w') || args.includes('--web');
        const goal = goalIdx !== -1 ? args.slice(goalIdx + 1).join(' ') : (rest.join(' ') || question || promptText || '').trim();
        if (!goal) { printError('Uso: fazai complex -g "objetivo" [--web]'); process.exit(2); }
        printInfo(`Executando fluxo complexo: ${goal}${allowWeb?' (web on)':''}`);
        try {
          const res = await axios.post(`${API_URL}/complex_flow`, { goal, allow_web: allowWeb });
          console.log(JSON.stringify(res.data, null, 2));
          process.exit(0);
        } catch (e) {
          printError(`Falha complex_flow: ${e.message}`);
          process.exit(1);
        }
      } else if (args[0] === 'opnsense') {
        // Faz chamada ao endpoint MCP OPNsense
        const axios = require('axios');
        const cmd = args[1] || 'get_system_info';
        const payload = { command: cmd };
        printInfo(`Executando OPNsense MCP: ${cmd}`);
        try {
          const res = await axios.post(`${API_URL}/opnsense`, payload);
          console.log(JSON.stringify(res.data, null, 2));
          process.exit(0);
        } catch (e) {
          printError(`Falha OPNsense: ${e.message}`);
          process.exit(1);
        }
      } else if (args[0] === 'doctor') {
        const axios = require('axios');
        const fs = require('fs');
        let ok = true;
        try { const h = await axios.get(`${API_URL}/health`, { timeout: 3000 }); console.log(`[health] ${h.status}`); } catch (e) { ok=false; console.log(`[health] FAIL ${e.message}`); }
        try { const s = await axios.get(`${API_URL}/status`, { timeout: 3000 }); console.log(`[status] version=${s.data?.version}`); } catch (e) { ok=false; console.log(`[status] FAIL ${e.message}`); }
        const must = ['/opt/fazai/lib/main.js','/opt/fazai/lib/mcp_opnsense.js','/opt/fazai/lib/complex_tasks.js','/opt/fazai/tools/web_search.js','/opt/fazai/tools/fazai_web_frontend.html'];
        must.forEach(p=>console.log(`[file] ${p} ${fs.existsSync(p)?'OK':'MISS'}`));
        const sec = ['/opt/fazai/tools/suricata_setup.js','/opt/fazai/tools/modsecurity_setup.js','/opt/fazai/tools/crowdsec_setup.js','/opt/fazai/tools/spamexperts.js','/opt/fazai/tools/cloudflare.js'];
        sec.forEach(p=>console.log(`[tool] ${p} ${fs.existsSync(p)?'OK':'MISS'}`));
        process.exit(ok?0:1);
      } else {
        // Para outros comandos b√°sicos
        const { exec } = require('child_process');
        printInfo(`Executando comando b√°sico: ${basicCommands[args[0]]}`);
        
        exec(basicCommands[args[0]], (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar comando: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}Resultado:${colors.reset}\n${stdout}\n`);
          process.exit(0);
        });
      }
    } catch (err) {
      printError(`Erro ao executar comando b√°sico: ${err.message}`);
      process.exit(1);
    }
  }
  
  if (args[0] === 'check-deps' || args[0] === 'verificar-deps') {
    printInfo("Verificando depend√™ncias do FazAI...");
    
    // Verifica depend√™ncias do Node.js
    try {
      const nodeVersion = process.version;
      printSuccess(`Node.js: ${nodeVersion}`);
      
      // Verifica vers√£o m√≠nima
      const versionNum = nodeVersion.substring(1); // Remove o 'v'
      const major = parseInt(versionNum.split('.')[0], 10);
      
      if (major < 18) {
        printError(`Vers√£o do Node.js (${nodeVersion}) √© menor que a m√≠nima requerida (v18.0.0)`);
      } else {
        printSuccess("Vers√£o do Node.js √© compat√≠vel");
      }
    } catch (err) {
      printError(`Erro ao verificar vers√£o do Node.js: ${err.message}`);
    }
    
    // Verifica arquivo principal
    try {
      if (fs.existsSync('/opt/fazai/lib/main.js')) {
        printSuccess('Arquivo principal: Encontrado em /opt/fazai/lib/main.js');
      } else {
        printError('Arquivo principal: N√£o encontrado');
      }
    } catch (err) {
      printError(`Erro ao verificar arquivo principal: ${err.message}`);
    }
    
    // Verifica depend√™ncias npm
    const dependencies = [
      { name: 'axios', version: '0.27.2' },
      { name: 'express', version: '4.18.1' },
      { name: 'winston', version: '3.8.1' },
      { name: 'ffi-napi-v22', version: '0.0.1' }
    ];
    
    dependencies.forEach(dep => {
      try {
        const depPackage = require(`${dep.name}/package.json`);
        printSuccess(`${dep.name}: ${depPackage.version} (requerido: ${dep.version})`);
      } catch (err) {
        printError(`${dep.name}: N√£o encontrado ou n√£o pode ser carregado`);
      }
    });
    
    // Verifica diret√≥rios e arquivos
    const paths = [
      { path: '/opt/fazai', type: 'dir', desc: 'Diret√≥rio de instala√ß√£o' },
      { path: '/opt/fazai/lib/main.js', type: 'file', desc: 'Arquivo principal' },
      { path: '/opt/fazai/tools', type: 'dir', desc: 'Diret√≥rio de ferramentas' },
      { path: '/opt/fazai/mods', type: 'dir', desc: 'Diret√≥rio de m√≥dulos' },
      { path: '/etc/fazai', type: 'dir', desc: 'Diret√≥rio de configura√ß√£o' },
      { path: '/etc/fazai/fazai.conf', type: 'file', desc: 'Arquivo de configura√ß√£o' },
      { path: '/var/log/fazai/fazai.log', type: 'file', desc: 'Arquivo de log', optional: true },
      { path: '/var/lib/fazai', type: 'dir', desc: 'Diret√≥rio de dados', optional: true }
    ];
    
    paths.forEach(item => {
      try {
        const exists = fs.existsSync(item.path);
        if (exists) {
          const stats = fs.statSync(item.path);
          if ((item.type === 'dir' && stats.isDirectory()) || 
              (item.type === 'file' && stats.isFile())) {
            printSuccess(`${item.desc} (${item.path}): OK`);
          } else {
            printError(`${item.desc} (${item.path}): Tipo incorreto`);
          }
        } else if (item.optional) {
          printInfo(`${item.desc} (${item.path}): N√£o encontrado (opcional)`);
        } else {
          printError(`${item.desc} (${item.path}): N√£o encontrado`);
        }
      } catch (err) {
        printError(`Erro ao verificar ${item.path}: ${err.message}`);
      }
    });
    
    // Verifica servi√ßo systemd
    try {
      const systemctl = spawn('systemctl', ['status', 'fazai']);
      let output = '';
      
      systemctl.stdout.on('data', (data) => {
        output += data.toString();
      });
      
      systemctl.stderr.on('data', (data) => {
        output += data.toString();
      });
      
      systemctl.on('close', (code) => {
        if (code === 0) {
          if (output.includes('Active: active (running)')) {
            printSuccess('Servi√ßo systemd: Ativo e em execu√ß√£o');
          } else if (output.includes('Active: inactive')) {
            printError('Servi√ßo systemd: Inativo');
          } else {
            printWarning('Servi√ßo systemd: Status desconhecido');
            console.log(output);
          }
        } else {
          printError(`Servi√ßo systemd: N√£o encontrado ou erro ao verificar (c√≥digo ${code})`);
        }
      });
    } catch (err) {
      printError(`Erro ao verificar servi√ßo systemd: ${err.message}`);
    }
    
    process.exit(0);
  }
  
  // Modo MCPS - planejamento passo a passo
  if (args[0] === 'mcps') {
    const mcpsCommand = args.slice(1).join(' ');
    if (!mcpsCommand) {
      printError('Nenhum comando fornecido para o modo MCPS.');
      process.exit(1);
    }

    try {
      printInfo(`Enviando comando MCPS${streamEnabled ? ' (stream)' : ''}: "${mcpsCommand}"`);
      if (streamEnabled) {
        await streamToConsole({ command: mcpsCommand, mcps: true });
        process.exit(0);
      }
      const result = await sendCommandMcps(mcpsCommand);

      if (result.success) {
        printSuccess('MCPS executado com sucesso.');

        if (result.steps) {
          result.steps.forEach((step, idx) => {
            console.log(`\n${colors.bright}${colors.fg.yellow}Passo ${idx + 1}:${colors.reset} ${step.command}\n${step.output}\n`);
          });
        }
      } else {
        printError(`Falha no MCPS: ${result.error || 'Erro desconhecido'}`);
      }
    } catch (err) {
      printError(err.message);
      process.exit(1);
    }

    process.exit(0);
  }

  // Verificar se √© o subcomando agent
  if (args[0] === 'agent') {
    if (args.length < 2) {
      printError('Objetivo √© obrigat√≥rio para o comando agent');
      console.log(`${colors.fg.cyan}Uso: fazai agent "seu objetivo aqui"${colors.reset}`);
      process.exit(1);
    }
    
    const objective = args.slice(1).join(' ');
    await runAgent(objective);
    process.exit(0);
  }

  // Comando normal para o FazAI
  const command = args.join(' ');
  
  try {
    printInfo(`Enviando comando${streamEnabled ? ' (stream)' : ''}${questionMode ? ' (question)' : ''}: "${command}"`);
    if (streamEnabled) {
      await streamToConsole({ command, question: questionMode });
      process.exit(0);
    }
    if (rawArgs.includes('-w') || rawArgs.includes('--web')) {
      // For√ßa pesquisa web
      const axios = require('axios');
      const res = await axios.post(`${API_URL}/search`, { query: command });
      if (res.data && res.data.success) {
        const first = res.data.first;
        if (first && first.url) {
          console.log(first.url);
        } else {
          console.log(JSON.stringify(res.data.results.slice(0, 3), null, 2));
        }
        process.exit(0);
      } else {
        printError(`Falha na pesquisa web: ${res.data && res.data.error ? res.data.error : 'erro'}`);
        process.exit(1);
      }
    }
    const result = await sendCommand(questionMode ? { question: true, command } : command);
    
    if (result.success) {
      printSuccess('Comando executado com sucesso.');
      
      if (result.interpretation) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Interpreta√ß√£o:${colors.reset} ${result.interpretation}\n`);
      }
      
      if (result.result) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Resultado:${colors.reset}\n${result.result}\n`);
      }
    } else {
      if (result.interpretation) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Interpreta√ß√£o:${colors.reset} ${result.interpretation}\n`);
      }
      
      printError(`Falha ao executar comando: ${result.error || 'Erro desconhecido'}`);
      
      if (result.details) {
        printInfo(`Detalhes t√©cnicos: ${result.details}`);
      }
      
      // Sugest√µes para problemas comuns
      if (result.error && result.error.includes('API')) {
        printInfo('Sugest√£o: Verifique se as chaves de API est√£o configuradas corretamente no arquivo .env ou /etc/fazai/fazai.conf');
      } else if (result.error && (result.error.includes('conectar') || result.error.includes('conex√£o'))) {
        printInfo('Sugest√£o: Verifique se o daemon est√° em execu√ß√£o com "systemctl status fazai" ou inicie-o com "systemctl start fazai"');
      }
    }
  } catch (err) {
    printError(err.message);
    
    // Sugest√µes para erros comuns
    if (err.message.includes('conectar') || err.message.includes('ECONNREFUSED')) {
      printInfo('Sugest√£o: O daemon FazAI parece n√£o estar em execu√ß√£o. Tente iniciar o servi√ßo com:');
      console.log(`${colors.fg.cyan}  sudo systemctl start fazai${colors.reset}`);
      printInfo('Para verificar o status do servi√ßo, use:');
      console.log(`${colors.fg.cyan}  sudo systemctl status fazai${colors.reset}`);
    } else if (err.message.includes('timeout')) {
      printInfo('Sugest√£o: A conex√£o com o daemon expirou. Isso pode ocorrer se:');
      console.log(`${colors.fg.cyan}  1. O daemon est√° sobrecarregado${colors.reset}`);
      console.log(`${colors.fg.cyan}  2. A conex√£o com o provedor de IA est√° lenta${colors.reset}`);
      console.log(`${colors.fg.cyan}  3. O comando √© muito complexo e est√° demorando para ser processado${colors.reset}`);
    }
    
    process.exit(1);
  }
}

// Executa a fun√ß√£o principal
main().catch(err => {
  printError(`Erro n√£o tratado: ${err.message}`);
  process.exit(1);
});
