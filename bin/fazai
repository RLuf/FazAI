#!/usr/bin/env node
// Habilita modo debug para verbose em tempo real
let debugEnabled = false;

/*
 * FazAI - Orquestrador Inteligente de Automa√ß√£o
 * Autor: Roger Luft
 * Licen√ßa: Creative Commons Attribution 4.0 International (CC BY 4.0)
 * https://creativecommons.org/licenses/by/4.0/
 */

/**
 * FazAI - Orquestrador Inteligente de Automa√ß√£o
 * CLI (Command Line Interface)
 * 
 * Este arquivo implementa a interface de linha de comando do FazAI, respons√°vel por:
 * - Receber comandos do usu√°rio
 * - Enviar comandos para o daemon
 * - Exibir resultados para o usu√°rio
 */

// Verifica√ß√£o de depend√™ncias
let axios;
try {
  axios = require('axios');
} catch (err) {
  console.error('\x1b[31m[ERRO] M√≥dulo axios n√£o encontrado. Por favor, instale-o com:\x1b[0m');
  console.error('\x1b[33m  npm install -g axios\x1b[0m');
  console.error('\x1b[33m  ou\x1b[0m');
  console.error('\x1b[33m  cd /opt/fazai && npm install axios\x1b[0m');
  process.exit(1);
}

// Verifica√ß√£o de outras depend√™ncias cr√≠ticas
let fs, path, readline, spawn;
try {
  fs = require('fs');
  path = require('path');
  readline = require('readline');
  const childProcess = require('child_process');
  spawn = childProcess.spawn;
} catch (err) {
  console.error('\x1b[31m[ERRO] M√≥dulo Node.js b√°sico n√£o encontrado: ' + err.message + '\x1b[0m');
  console.error('\x1b[33m  Verifique sua instala√ß√£o do Node.js\x1b[0m');
  process.exit(1);
}

// Verifica√ß√£o do arquivo principal
const mainJsPath = '/opt/fazai/lib/main.js';
if (!fs.existsSync(mainJsPath)) {
  console.error('\x1b[31m[ERRO] Arquivo principal n√£o encontrado: ' + mainJsPath + '\x1b[0m');
  console.error('\x1b[33m  Verifique se o FazAI est√° instalado corretamente\x1b[0m');
  process.exit(1);
}

// API base (daemon)
const API_URL = process.env.FAZAI_API_URL || 'http://localhost:3120';

// ===== Fun√ß√µes utilit√°rias de documenta√ß√£o e ferramentas =====
function showDocumentation() {
  const manual = '/opt/fazai/MANUAL_FERRAMENTAS.md';
  const usage = '/opt/fazai/USAGE.md';
  const { exec } = require('child_process');
  const paths = [manual, usage].filter(p => fs.existsSync(p));
  if (paths.length === 0) {
    console.log('Documenta√ß√£o n√£o encontrada em /opt/fazai.');
    return;
  }
  const toOpen = paths.join(' ');
  exec(`xdg-open ${toOpen} 2>/dev/null || open ${toOpen} 2>/dev/null || cat ${toOpen}`);
}

function showAvailableTools(dir = '/opt/fazai/tools') {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    const tools = entries
      .filter(e => e.isFile() && /\.(js|sh)$/.test(e.name) && !e.name.startsWith('.'))
      .map(e => e.name)
      .sort();
    console.log('Ferramentas dispon√≠veis:');
    tools.forEach(t => console.log('  -', t));
  } catch (e) {
    console.error('N√£o foi poss√≠vel listar ferramentas em', dir, e.message);
  }
}

function showToolHelp(name, dir = '/opt/fazai/tools') {
  if (!name) { console.error('Informe o nome da ferramenta.'); return; }
  const file = `${dir}/${name}`;
  if (fs.existsSync(file)) {
    console.log(`Ajuda para ${name}:`);
    try {
      const content = fs.readFileSync(file, 'utf8');
      const lines = content.split('\n').slice(0, 60).join('\n');
      console.log(lines);
    } catch (e) {
      console.error('Erro ao ler a ferramenta:', e.message);
    }
  } else {
    console.error('Ferramenta n√£o encontrada:', name);
  }
}

// Fun√ß√£o para executar comandos do relay
async function runRelayCommand(command, args = []) {
  try {
    const endpoint = `/relay/${command}`;
    let response;
    
    switch (command) {
      case 'analyze':
        response = await axios.post(`${API_URL}${endpoint}`);
        break;
      case 'configure':
        response = await axios.post(`${API_URL}${endpoint}`, {});
        break;
      case 'monitor':
        response = await axios.get(`${API_URL}${endpoint}`);
        break;
      case 'stats':
        response = await axios.get(`${API_URL}${endpoint}`);
        break;
      case 'spamexperts':
        response = await axios.post(`${API_URL}${endpoint}`, {});
        break;
      case 'zimbra':
        response = await axios.post(`${API_URL}${endpoint}`, {});
        break;
      case 'blacklist':
        if (args.length === 0) {
          printError('IP √© obrigat√≥rio para o comando blacklist');
          process.exit(1);
        }
        response = await axios.post(`${API_URL}${endpoint}`, { ip: args[0] });
        break;
      case 'restart':
        response = await axios.post(`${API_URL}${endpoint}`);
        break;
      default:
        printError(`Comando relay desconhecido: ${command}`);
        process.exit(1);
    }
    
    if (response.data.ok) {
      console.log('\x1b[32m‚úì Sucesso:\x1b[0m', response.data.message || 'Comando executado');
      if (response.data.config) {
        console.log('\x1b[36mConfigura√ß√£o:\x1b[0m', JSON.stringify(response.data.config, null, 2));
      }
      if (response.data.stats) {
        console.log('\x1b[36mEstat√≠sticas:\x1b[0m', JSON.stringify(response.data.stats, null, 2));
      }
      if (response.data.recommendations) {
        console.log('\x1b[33mRecomenda√ß√µes:\x1b[0m');
        response.data.recommendations.forEach(rec => {
          console.log(`  ‚Ä¢ ${rec}`);
        });
      }
    } else {
      console.error('\x1b[31m‚ùå Erro:\x1b[0m', response.data.error);
      process.exit(1);
    }
  } catch (error) {
    console.error('\x1b[31m‚ùå Erro ao executar comando relay:\x1b[0m', error.message);
    process.exit(1);
  }
}

// Fun√ß√£o para executar comandos DOCLER
async function runDoclerCommand(command, args = []) {
  try {
    const { exec } = require('child_process');
    const { promisify } = require('util');
    const execAsync = promisify(exec);
    
    switch (command) {
      case 'start':
        console.log('\x1b[36müöÄ Iniciando servidor web DOCLER...\x1b[0m');
        try {
          const result = await execAsync('node /opt/fazai/web/docler-server.js');
          console.log('\x1b[32m‚úì Servidor DOCLER iniciado com sucesso!\x1b[0m');
          console.log('\x1b[36müì± Cliente: http://localhost:3220\x1b[0m');
          console.log('\x1b[36müîß Admin: http://localhost:3221\x1b[0m');
        } catch (error) {
          console.error('\x1b[31m‚ùå Erro ao iniciar servidor DOCLER:\x1b[0m', error.message);
        }
        break;
        
      case 'stop':
        console.log('\x1b[36müõë Parando servidor web DOCLER...\x1b[0m');
        try {
          await execAsync('pkill -f "docler-server.js"');
          console.log('\x1b[32m‚úì Servidor DOCLER parado com sucesso!\x1b[0m');
        } catch (error) {
          console.error('\x1b[31m‚ùå Erro ao parar servidor DOCLER:\x1b[0m', error.message);
        }
        break;
        
      case 'status':
        console.log('\x1b[36müìä Verificando status do servidor DOCLER...\x1b[0m');
        try {
          const result = await execAsync('pgrep -f "docler-server.js"');
          if (result.stdout.trim()) {
            console.log('\x1b[32m‚úì Servidor DOCLER est√° rodando!\x1b[0m');
            console.log('\x1b[36müì± Cliente: http://localhost:3220\x1b[0m');
            console.log('\x1b[36müîß Admin: http://localhost:3221\x1b[0m');
          } else {
            console.log('\x1b[33m‚ö†Ô∏è Servidor DOCLER n√£o est√° rodando\x1b[0m');
          }
        } catch (error) {
          console.log('\x1b[33m‚ö†Ô∏è Servidor DOCLER n√£o est√° rodando\x1b[0m');
        }
        break;
        
      case 'admin':
        console.log('\x1b[36müîß Abrindo painel administrativo DOCLER...\x1b[0m');
        try {
          await execAsync('xdg-open http://localhost:3121 2>/dev/null || open http://localhost:3121 2>/dev/null || echo "Abra manualmente: http://localhost:3121"');
          console.log('\x1b[32m‚úì Painel administrativo aberto!\x1b[0m');
        } catch (error) {
          console.log('\x1b[36müì± Abra manualmente: http://localhost:3121\x1b[0m');
        }
        break;
        
      default:
        // Comando padr√£o: abrir interface cliente
        console.log('\x1b[36müì± Abrindo interface DOCLER...\x1b[0m');
        try {
          await execAsync('xdg-open http://localhost:3120 2>/dev/null || open http://localhost:3120 2>/dev/null || echo "Abra manualmente: http://localhost:3120"');
          console.log('\x1b[32m‚úì Interface DOCLER aberta!\x1b[0m');
        } catch (error) {
          console.log('\x1b[36müì± Abra manualmente: http://localhost:3120\x1b[0m');
        }
        break;
    }
  } catch (error) {
    console.error('\x1b[31m‚ùå Erro ao executar comando DOCLER:\x1b[0m', error.message);
    process.exit(1);
  }
}

// Fun√ß√£o para executar agente inteligente
async function runAgent(objective) {
  try {
    console.log('\x1b[36mü§ñ FazAI Agent iniciando...\x1b[0m');
    console.log('\x1b[33mObjetivo:\x1b[0m', objective);
    console.log('');

    // Criar sess√£o
    const sessionResponse = await axios.post(`${API_URL}/agent/sessions`, {});
    if (!sessionResponse.data.ok) {
      throw new Error('Falha ao criar sess√£o');
    }
    
    const sessionId = sessionResponse.data.session_id;
    console.log('\x1b[32m‚úì Sess√£o criada:\x1b[0m', sessionId);

    // Configurar handler de interrup√ß√£o
    process.on('SIGINT', async () => {
      console.log('\n\x1b[33müõë Interrompendo agente...\x1b[0m');
      try {
        await axios.post(`${API_URL}/agent/abort`, { session_id: sessionId });
      } catch (e) {
        // Ignorar erros de abort
      }
      process.exit(130);
    });

    // Iniciar stream SSE
    const response = await axios.post(`${API_URL}/agent/generate`, {
      session_id: sessionId,
      objective: objective,
      history: []
    }, {
      responseType: 'stream',
      headers: {
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache'
      }
    });

    let buffer = '';
    
    response.data.on('data', (chunk) => {
      buffer += chunk.toString();
      
      // Processar eventos SSE
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const event = JSON.parse(line.slice(6));
            handleAgentEvent(event);
          } catch (e) {
            // Ignorar linhas que n√£o s√£o JSON v√°lido
          }
        }
      }
    });

    response.data.on('end', () => {
      console.log('\n\x1b[32m‚úÖ Agente conclu√≠do\x1b[0m');
    });

    response.data.on('error', (error) => {
      console.error('\n\x1b[31m‚ùå Erro no stream:\x1b[0m', error.message);
    });

  } catch (error) {
    console.error('\x1b[31m‚ùå Erro ao executar agente:\x1b[0m', error.message);
    process.exit(1);
  }
}

// Handler de eventos do agente
function handleAgentEvent(event) {
  switch (event.type) {
    case 'token':
      process.stdout.write(event.text);
      break;
      
    case 'plan':
      console.log('\n\x1b[35müìã Plano:\x1b[0m', event.steps.join(' ‚Üí '));
      break;
      
    case 'action':
      console.log('\n\x1b[34m‚ö° A√ß√£o:\x1b[0m', event.action, event.command || event.name || '');
      break;
      
    case 'exec_log':
      process.stdout.write(event.chunk);
      break;
      
    case 'observe':
      console.log('\n\x1b[36müëÅÔ∏è  Observa√ß√£o:\x1b[0m', event.note);
      break;
      
    case 'ask':
      console.log('\n\x1b[33m‚ùì Pergunta:\x1b[0m', event.question);
      if (event.options && event.options.length > 0) {
        console.log('\x1b[33mOp√ß√µes:\x1b[0m');
        event.options.forEach((option, i) => {
          console.log(`  ${i + 1}. ${option}`);
        });
      }
      // TODO: Implementar intera√ß√£o com usu√°rio
      break;
      
    case 'done':
      console.log('\n\x1b[32m‚úÖ Itera√ß√£o conclu√≠da\x1b[0m');
      if (event.result) {
        console.log('\x1b[32mResultado:\x1b[0m', event.result);
      }
      break;
      
    case 'error':
      console.error('\n\x1b[31m‚ùå Erro:\x1b[0m', event.message);
      break;
      
    default:
      // Ignorar eventos desconhecidos
      break;
  }
}

// Configura√ß√£o do cliente
const LOG_FILE = '/var/log/fazai/fazai.log';
const STREAM_URL = `${API_URL}/command/stream`;

// Cores para sa√≠da no terminal
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  underscore: '\x1b[4m',
  blink: '\x1b[5m',
  reverse: '\x1b[7m',
  hidden: '\x1b[8m',
  
  fg: {
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m'
  },
  
  bg: {
    black: '\x1b[40m',
    red: '\x1b[41m',
    green: '\x1b[42m',
    yellow: '\x1b[43m',
    blue: '\x1b[44m',
    magenta: '\x1b[45m',
    cyan: '\x1b[46m',
    white: '\x1b[47m'
  }
};
/**
 * Exibe mensagem de debug se modo debug estiver ativo
 * @param {string} message - Mensagem de debug
 */
function printDebug(message) {
  if (debugEnabled) console.log(`${colors.fg.magenta}[DEBUG] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem de erro formatada
 * @param {string} message - Mensagem de erro
 */
function printError(message) {
  console.error(`${colors.fg.red}[ERRO] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem de sucesso formatada
 * @param {string} message - Mensagem de sucesso
 */
function printSuccess(message) {
  console.log(`${colors.fg.green}[SUCESSO] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem informativa formatada
 * @param {string} message - Mensagem informativa
 */
function printInfo(message) {
  console.log(`${colors.fg.cyan}[INFO] ${message}${colors.reset}`);
}

/**
 * Exibe mensagem de aviso formatada
 * @param {string} message - Mensagem de aviso
 */
function printWarning(message) {
  console.log(`${colors.fg.yellow}[AVISO] ${message}${colors.reset}`);
}

/**
 * Envia comando para o daemon
 * @param {string} command - Comando a ser enviado
 * @returns {Promise<object>} - Resposta do daemon
 */
async function sendCommand(command) {
  // Aceita string (comando) ou objeto ({ command, question, mcps, cwd })
  const body = (command && typeof command === 'object' && !Array.isArray(command)) ? command : { command };
  // Debug: mostra detalhes da requisi√ß√£o
  printDebug(`[sendCommand] POST ${API_URL}/command payload: ${JSON.stringify(body)}`);
  try {
    printInfo(`Conectando ao daemon em ${API_URL}...`);
    const response = await axios.post(`${API_URL}/command`, body, {
      timeout: body && body.question ? 180000 : 30000 // 3min para perguntas, 30s padr√£o
    });
    // Debug: mostra detalhes da resposta HTTP
    printDebug(`[sendCommand] HTTP ${response.status} ${response.statusText}`);
    printDebug(`[sendCommand] response.data: ${JSON.stringify(response.data)}`);
    
    if (!response.data.success) {
      if (response.data.error) {
        throw new Error(response.data.error);
      } else if (response.data.interpretation) {
        printWarning(`O comando foi interpretado, mas a execu√ß√£o falhou: ${response.data.interpretation}`);
        if (response.data.details) {
          printError(`Detalhes do erro: ${response.data.details}`);
        }
        return response.data;
      } else {
        throw new Error('Resposta do servidor indica falha, mas sem detalhes espec√≠ficos');
      }
    }
    
    return response.data;
  } catch (err) {
    if (err.response) {
      // Erro com resposta do servidor
      const errorData = err.response.data;
      if (errorData && errorData.error) {
        throw new Error(`Erro do servidor: ${errorData.error}`);
      } else if (errorData && errorData.details) {
        throw new Error(`Erro do servidor: ${errorData.details}`);
      } else {
        throw new Error(`Erro do servidor: ${err.response.status} ${err.response.statusText}`);
      }
    } else if (err.request) {
      // Erro sem resposta (problema de conex√£o)
      throw new Error(`N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o em ${API_URL}.`);
    } else {
      // Erro na configura√ß√£o da requisi√ß√£o
      throw new Error(`Erro ao enviar comando: ${err.message}`);
    }
  }
}

/**
 * Conecta ao endpoint SSE e imprime eventos em tempo real
 * @param {{command: string, mcps?: boolean, cwd?: string, question?: boolean}} body
 */
async function streamToConsole(body) {
  const http = require('http');
  const https = require('https');
  const url = require('url');
  const parsed = url.parse(STREAM_URL);
  const isHttps = parsed.protocol === 'https:';
  const lib = isHttps ? https : http;

  const payload = JSON.stringify(body);
  const options = {
    method: 'POST',
    hostname: parsed.hostname,
    port: parsed.port || (isHttps ? 443 : 80),
    path: parsed.path,
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(payload)
    }
  };

  printInfo(`Conectando (SSE) a ${STREAM_URL}...`);
  await new Promise((resolve, reject) => {
    const req = lib.request(options, (res) => {
      if (res.statusCode < 200 || res.statusCode >= 300) {
        reject(new Error(`Status HTTP ${res.statusCode}`));
        return;
      }

      res.setEncoding('utf8');
      let buffer = '';

      const flushBuffer = () => {
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          if (line.startsWith('event:')) {
            // armazenado at√© pr√≥ximo data
            streamToConsole._currentEvent = line.slice(6).trim();
          } else if (line.startsWith('data:')) {
            const ev = (streamToConsole._currentEvent || 'message');
            const raw = line.slice(5).trim();
            let data;
            try { data = JSON.parse(raw); } catch { data = { text: raw }; }
            renderSseEvent(ev, data);
          }
        }
      };

      res.on('data', (chunk) => { buffer += chunk; flushBuffer(); });
      res.on('end', () => { flushBuffer(); resolve(); });
    });
    req.on('error', reject);
    req.write(payload);
    req.end();
  });
}

function renderSseEvent(event, data) {
  switch (event) {
    case 'received':
      printInfo(`Recebido pelo daemon: "${data.command}" (mcps=${!!data.mcps})`);
      break;
    case 'phase':
      printInfo(`Fase: ${data.phase}`);
      break;
    case 'interpretation':
      if (data.interpretation) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Interpreta√ß√£o:${colors.reset} ${data.interpretation}\n`);
      }
      break;
    case 'stdout':
      process.stdout.write(data.chunk);
      break;
    case 'stderr':
      process.stderr.write(`${colors.fg.yellow}${data.chunk}${colors.reset}`);
      break;
    case 'steps':
      if (Array.isArray(data.steps)) {
        printInfo(`MCPS: ${data.steps.length} passos gerados`);
      }
      break;
    case 'step_start':
      console.log(`\n${colors.bright}${colors.fg.cyan}Iniciando passo ${data.index + 1}:${colors.reset} ${data.command}`);
      break;
    case 'step_stdout':
      process.stdout.write(data.chunk);
      break;
    case 'step_stderr':
      process.stderr.write(`${colors.fg.yellow}${data.chunk}${colors.reset}`);
      break;
    case 'step_end':
      const status = data.code === 0 ? `${colors.fg.green}OK${colors.reset}` : `${colors.fg.red}FAIL (code ${data.code})${colors.reset}`;
      console.log(`\n${colors.bright}Passo ${data.index + 1} finalizado:${colors.reset} ${status}`);
      break;
    case 'plan_results':
      printInfo('Plano arquitetado executado.');
      break;
    case 'interactive':
      printWarning('Intera√ß√£o requerida pelo plano. Abra a interface apropriada.');
      break;
    case 'answer':
      console.log(`\n${colors.bright}${colors.fg.yellow}Resposta:${colors.reset}\n${data.answer}\n`);
      break;
    case 'exit':
      // apenas informativo
      break;
    case 'done':
      printSuccess(`Conclu√≠do (success=${data.success})`);
      break;
    case 'error':
      printError(data.message || 'Erro');
      break;
    default:
      if (data?.text) console.log(data.text);
  }
}

/**
 * Envia comando para o daemon no modo MCPS
 * @param {string} command - Comando a ser enviado
 * @returns {Promise<object>} - Resposta do daemon
 */
async function sendCommandMcps(command) {
  // Debug: mostra detalhes da requisi√ß√£o MCPS
  printDebug(`[sendCommandMcps] POST ${API_URL}/command payload: ${JSON.stringify({command, mcps: true})}`);
  try {
    printInfo(`Conectando ao daemon em ${API_URL} (MCPS)...`);
    const response = await axios.post(`${API_URL}/command`, { command, mcps: true }, {
      timeout: 30000 // 30 segundos de timeout
    });
    // Debug: mostra detalhes da resposta MCPS
    printDebug(`[sendCommandMcps] HTTP ${response.status} ${response.statusText}`);
    printDebug(`[sendCommandMcps] response.data: ${JSON.stringify(response.data)}`);

    if (!response.data.success) {
      if (response.data.error) {
        throw new Error(response.data.error);
      } else if (response.data.interpretation) {
        printWarning(`O comando foi interpretado, mas a execu√ß√£o falhou: ${response.data.interpretation}`);
        if (response.data.details) {
          printError(`Detalhes do erro: ${response.data.details}`);
        }
        return response.data;
      } else {
        throw new Error('Resposta do servidor indica falha, mas sem detalhes espec√≠ficos');
      }
    }

    return response.data;
  } catch (err) {
    if (err.response) {
      const errorData = err.response.data;
      if (errorData && errorData.error) {
        throw new Error(`Erro do servidor: ${errorData.error}`);
      } else if (errorData && errorData.details) {
        throw new Error(`Erro do servidor: ${errorData.details}`);
      } else {
        throw new Error(`Erro do servidor: ${err.response.status} ${err.response.statusText}`);
      }
    } else if (err.request) {
      throw new Error(`N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o em ${API_URL}.`);
    } else {
      throw new Error(`Erro ao enviar comando: ${err.message}`);
    }
  }
}

/**
 * Solicita recarga de plugins e m√≥dulos
 * @returns {Promise<object>} - Resposta do daemon
 */
async function reloadModules() {
  try {
    const response = await axios.post(`${API_URL}/reload`);
    return response.data;
  } catch (err) {
    if (err.response) {
      throw new Error(`Erro do servidor: ${err.response.data.error || 'Desconhecido'}`);
    } else if (err.request) {
      throw new Error('N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o.');
    } else {
      throw new Error(`Erro ao recarregar m√≥dulos: ${err.message}`);
    }
  }
}

/**
 * Executa comando systemctl para o servi√ßo FazAI
 * @param {string} action - start | stop | restart | status
 */
function systemctlCommand(action) {
  const { spawnSync } = require('child_process');
  printInfo(`Executando systemctl ${action} fazai...`);
  const result = spawnSync('systemctl', [action, 'fazai'], { encoding: 'utf8' });
  if (result.stdout) console.log(result.stdout.trim());
  if (result.stderr) console.error(result.stderr.trim());
  return result.status === 0;
}

/**
 * Exibe as √∫ltimas linhas do arquivo de log
 * @param {number} lines - N√∫mero de linhas a exibir
 */
function showLogs(lines = 10) {
  try {
    if (!fs.existsSync(LOG_FILE)) {
      printError(`Arquivo de log n√£o encontrado: ${LOG_FILE}`);
      return;
    }
    
    const logContent = fs.readFileSync(LOG_FILE, 'utf8');
    const logLines = logContent.split('\n').filter(line => line.trim() !== '');
    
    const lastLines = logLines.slice(-lines);
    
    console.log(`\n${colors.bright}${colors.fg.yellow}=== √öltimas ${lines} entradas de log ===${colors.reset}\n`);
    
    lastLines.forEach(line => {
      try {
        const logEntry = JSON.parse(line);
        const timestamp = new Date(logEntry.timestamp).toLocaleString();
        const level = logEntry.level.toUpperCase();
        const message = logEntry.message;
        
        let levelColor = colors.fg.white;
        switch (level) {
          case 'ERROR':
            levelColor = colors.fg.red;
            break;
          case 'WARN':
            levelColor = colors.fg.yellow;
            break;
          case 'INFO':
            levelColor = colors.fg.green;
            break;
          case 'DEBUG':
            levelColor = colors.fg.cyan;
            break;
        }
        
        console.log(`${colors.dim}[${timestamp}]${colors.reset} ${levelColor}${level}${colors.reset}: ${message}`);
      } catch (err) {
        console.log(line);
      }
    });
    
    console.log(`\n${colors.bright}${colors.fg.yellow}=== Fim dos logs ===${colors.reset}\n`);
  } catch (err) {
    printError(`Erro ao ler logs: ${err.message}`);
  }
}

/**
 * Limpa o arquivo de log
 */
async function clearLogs() {
  try {
    printInfo('Limpando logs do FazAI...');
    
    const response = await axios.post(`${API_URL}/logs/clear`);
    
    if (response.data.success) {
      printSuccess('Logs limpos com sucesso!');
      if (response.data.backup) {
        printInfo(`Backup criado em: ${response.data.backup}`);
      }
    } else {
      printError(`Erro ao limpar logs: ${response.data.error}`);
    }
  } catch (err) {
    if (err.response) {
      printError(`Erro do servidor: ${err.response.data.error || 'Desconhecido'}`);
    } else if (err.request) {
      printError('N√£o foi poss√≠vel conectar ao daemon. Verifique se o servi√ßo est√° em execu√ß√£o.');
    } else {
      printError(`Erro ao limpar logs: ${err.message}`);
    }
  }
}

/**
 * Fun√ß√£o principal
 */
async function main() {
  // Obt√©m argumentos e normaliza flags em qualquer posi√ß√£o
  const rawArgs = process.argv.slice(2);
  let args = [];
  let streamEnabled = false;
  let questionMode = false;
  rawArgs.forEach((arg) => {
    if (arg === '-d' || arg === '--debug') {
      debugEnabled = true;
    } else if (arg === '--stream' || arg === '-s') {
      streamEnabled = true;
    } else if (arg === '-q' || arg === '--question') {
      questionMode = true;
    } else {
      args.push(arg);
    }
  });
  if (debugEnabled) printInfo('Modo debug ativado');

  // Comandos especiais
  if (args.length === 0) {
    printError('Nenhum comando fornecido. Use "fazai ajuda" para ver os comandos dispon√≠veis.');
    process.exit(1);
  }
  
  if (args[0] === 'ajuda' || args[0] === 'help' || args[0] === '--help') {
    console.log(`
${colors.bright}${colors.fg.cyan}FazAI v2.0.0${colors.reset}

${colors.bright}Compat√≠vel com:${colors.reset}
  ‚Ä¢ Debian/Ubuntu
  ‚Ä¢ Fedora/RedHat/CentOS
  ‚Ä¢ WSL (Debian/Ubuntu)

${colors.bright}Uso:${colors.reset}
  fazai [-d|--debug] [--stream|-s] [-q] <comando>
  fazai agent <objetivo>

${colors.bright}Comandos de Sistema:${colors.reset}
  ajuda, help, --help         Exibe esta mensagem de ajuda
  manual                      Abre o manual completo de utiliza√ß√£o
  docs                        Abre documenta√ß√£o (manual e uso)
  tools                       Lista ferramentas dispon√≠veis
  query "<termo>"             Pesquisa t√©cnica (Context7 quando dispon√≠vel)
  -d, --debug                 Ativa modo debug com verbose em tempo real
  versao, version, -v         Exibe a vers√£o do FazAI
  -q, --question              Pergunta direta (sem executar comandos)
  check-deps, verificar-deps  Verifica depend√™ncias e instala√ß√£o do sistema

${colors.bright}Comandos de Servi√ßo:${colors.reset}
  start                       Inicia o servi√ßo FazAI
  stop                        Para o servi√ßo FazAI
  restart                     Reinicia o servi√ßo FazAI
  status                      Mostra o status do servi√ßo FazAI
  reload                      Recarrega plugins e m√≥dulos
  check-deps                  Verifica depend√™ncias (inclui Gemma e flags de telemetria)
  telemetry --enable|--disable Ajusta flags [telemetry] no config e reinicia
  telemetry-smoke             Valida /ingest e /metrics conforme flags
  docler start|stop|status    Controla o servi√ßo web DOCLER (portas 3220/3221)

${colors.bright}Comandos de Logs:${colors.reset}
  logs [n]                    Exibe as √∫ltimas n entradas de log (padr√£o: 10)
  limpar-logs, clear-logs     Limpa o arquivo de log (cria backup)
  web                         Abre a interface web de gerenciamento

${colors.bright}Comandos de Sistema R√°pido:${colors.reset}
  kernel                      Exibe vers√£o do kernel (uname -r)
  sistema                     Exibe informa√ß√µes do sistema (uname -a)
  memoria                     Exibe uso de mem√≥ria (free -h)
  disco                       Exibe uso de disco (df -h)
  processos                   Lista processos (ps aux)
  rede                        Exibe interfaces de rede (ip a)
  data                        Mostra data e hora (date)
  uptime                      Tempo de atividade (uptime)

${colors.bright}Comandos de Visualiza√ß√£o:${colors.reset}
  html <tipo> [graf]          Gera gr√°fico HTML (tipo: memoria, disco, processos)
  tui                         Abre o dashboard TUI (ncurses)
  interactive                 Abre sess√£o interativa (WebSocket PTY)
  complex -g <objetivo> [--web] Executa fluxo complexo multi-etapas

${colors.bright}Comandos de Configura√ß√£o:${colors.reset}
  config                      Abre ferramenta de configura√ß√£o interativa
  cache                       Mostra status do cache de IA
  cache-clear                 Limpa o cache de IA

${colors.bright}Comandos de Pesquisa:${colors.reset}
  -q, --question              Pergunta direta (IA)
  -w, --web                   For√ßa pesquisa web (tool web_search)
  complex -g <objetivo>       Objetivo de alto n√≠vel; usa /complex_flow

${colors.bright}Modo Agent (Agente Inteligente):${colors.reset}
  agent <objetivo>            Exemplo: fazai agent "configurar servidor de email relay"
                              Executa agente inteligente com fluxo iterativo

${colors.bright}Modo Relay (Sistema SMTP):${colors.reset}
  relay analyze               Analisa configura√ß√£o atual do relay SMTP
  relay configure             Configura relay automaticamente com IA
  relay monitor               Monitora logs em tempo real e detecta ataques
  relay stats                 Mostra estat√≠sticas completas do sistema
  relay spamexperts           Integra com SpamExperts (whitelist/blacklist)
  relay zimbra                Integra com Zimbra (usu√°rios/dom√≠nios)
  relay blacklist <ip>        Adiciona IP malicioso √† blacklist
  relay restart               Reinicia o relay com novas configura√ß√µes

${colors.bright}Interface DOCLER (Web):${colors.reset}
  docler                      Abre interface web DOCLER (cliente)
  docler admin                Abre painel administrativo DOCLER
  docler start                Inicia servidor web DOCLER
  docler stop                 Para servidor web DOCLER
  docler status               Mostra status do servidor web

${colors.bright}Modo MCPS (Planejamento Passo a Passo):${colors.reset}
  mcps <tarefa>               Exemplo: fazai mcps atualizar o sistema
  mcps --stream <tarefa>      Executa MCPS com sa√≠da em tempo real

${colors.bright}Provedores de IA Suportados:${colors.reset}
  ‚Ä¢ Gemma local (padr√£o)      - Bin√°rio gemma.cpp via gemma_oneshot
  ‚Ä¢ Llama Server              - Servidor compat√≠vel OpenAI (llama.cpp server)
  ‚Ä¢ OpenRouter                - Gateway multi-modelos
  ‚Ä¢ OpenAI                    - GPT-4, GPT-3.5-turbo
  ‚Ä¢ Anthropic (Claude)        - Claude 3 Opus, Sonnet, Haiku
  ‚Ä¢ Google Gemini             - Gemini Pro, Pro Vision
  ‚Ä¢ Ollama                    - Modelos locais (llama3.2, mixtral, etc.)

${colors.bright}Sistema de Fallback:${colors.reset}
  O FazAI automaticamente tenta o pr√≥ximo provedor em caso de falha:
  Gemma (local) ‚Üí Llama server ‚Üí OpenRouter ‚Üí OpenAI ‚Üí Anthropic ‚Üí Gemini ‚Üí Ollama

${colors.bright}Exemplo de instala√ß√£o Fedora:${colors.reset}
  sudo dnf install -y nodejs npm python3 python3-pip gcc dialog
  sudo ./install.sh

${colors.bright}Exemplos de Uso:${colors.reset}
  fazai mostra os processos em execucao
  fazai cria um usuario com nome teste com a senha teste321 no grupo printers
  fazai instale os modulos mod_security do apache
  fazai altere a porta do ssh de 22 para 31052
                fazai agent "configurar servidor de email relay com antispam"
              fazai relay analyze                    # Analisa configura√ß√£o do relay
              fazai relay configure                  # Configura automaticamente
              fazai relay monitor                    # Monitora em tempo real
              fazai docler                           # Abre interface web DOCLER
              fazai docler admin                     # Abre painel administrativo
              fazai docler start                     # Inicia servidor web
  fazai mcps atualizar sistema
  fazai config                 # Configurar provedores de IA
  fazai cache                  # Verificar status do cache
  suricata_setup               # Instala/configura Suricata
  modsecurity_setup            # Instala/configura ModSecurity
  crowdsec_setup               # Instala/configura CrowdSec
  spamexperts                  # A√ß√µes em SpamExperts
  cloudflare                   # A√ß√µes na API Cloudflare

${colors.bright}Para mais informa√ß√µes:${colors.reset}
  ‚Ä¢ Documenta√ß√£o: README.md, USAGE.md
  ‚Ä¢ Logs: /var/log/fazai/fazai.log
  ‚Ä¢ Configura√ß√£o: /etc/fazai/fazai.conf (telemetria: [telemetry].enable_ingest/enable_metrics)
  ‚Ä¢ GitHub: https://github.com/RLuf/FazAI
    `);
    process.exit(0);
  }
  
  if (args[0] === 'manual') {
    const manualPath = '/opt/fazai/MANUAL_COMPLETO.md';
    if (fs.existsSync(manualPath)) {
      const { exec } = require('child_process');
      printInfo('Abrindo manual completo do FazAI...');
      
      // Tenta abrir com diferentes visualizadores
      const viewers = ['xdg-open', 'open', 'cat'];
      let viewerFound = false;
      
      for (const viewer of viewers) {
        if (viewer === 'cat') {
          exec(`cat "${manualPath}"`, (error, stdout, stderr) => {
            if (error) {
              printError(`Erro ao exibir manual: ${error.message}`);
              process.exit(1);
            }
            console.log(stdout);
            process.exit(0);
          });
          viewerFound = true;
          break;
        } else {
          exec(`which ${viewer}`, (error) => {
            if (!error) {
              exec(`${viewer} "${manualPath}"`, (error) => {
                if (error) {
                  printError(`Erro ao abrir manual: ${error.message}`);
                  process.exit(1);
                }
                printSuccess('Manual aberto com sucesso!');
                process.exit(0);
              });
              viewerFound = true;
            }
          });
          if (viewerFound) break;
        }
      }
      
      if (!viewerFound) {
        printError('Nenhum visualizador encontrado. Use: cat /opt/fazai/MANUAL_COMPLETO.md');
        process.exit(1);
      }
    } else {
      printError('Manual n√£o encontrado. Verifique se o arquivo MANUAL_COMPLETO.md est√° em /opt/fazai/');
      process.exit(1);
    }
  }
  
  // Abrir documenta√ß√£o (manual + uso)
  if (args[0] === 'docs') {
    showDocumentation();
    process.exit(0);
  }

  // Listar ferramentas dispon√≠veis
  if (args[0] === 'tools') {
    showAvailableTools();
    process.exit(0);
  }

  // Ajuda espec√≠fica para ferramenta: fazai help <ferramenta>
  if (args[0] === 'help' && args[1]) {
    showToolHelp(args[1]);
    process.exit(0);
  }

  // Pesquisa t√©cnica: fazai query "termo"
  if (args[0] === 'query') {
    const q = args.slice(1).join(' ').trim().replace(/^"|"$/g, '');
    if (!q) {
      console.error('Uso: fazai query "<termo>"');
      process.exit(1);
    }
    (async () => {
      try {
        const resp = await axios.get(`${API_URL}/research`, { params: { q, max: 5 } });
        if (!resp.data || !resp.data.success) {
          console.error('Falha na pesquisa:', resp.data && resp.data.error);
          process.exit(1);
        }
        const results = resp.data.results || [];
        if (!results.length) {
          console.log('Nenhum resultado.');
          process.exit(0);
        }
        console.log(`Resultados para: ${q}`);
        results.forEach((r, i) => {
          console.log(`\n[${i+1}] ${r.title || ''}`);
          if (r.url) console.log(`URL: ${r.url}`);
          if (r.snippet) console.log(r.snippet);
        });
        process.exit(0);
      } catch (e) {
        console.error('Erro ao consultar pesquisa:', e.message);
        process.exit(1);
      }
    })();
    return; // evita continuar fluxo
  }
  
  if (args[0] === 'logs') {
    const lines = args[1] ? parseInt(args[1], 10) : 10;
    showLogs(isNaN(lines) ? 10 : lines);
    process.exit(0);
  }

  // Smoke test de telemetria
  if (args[0] === 'telemetry-smoke') {
    try {
      const confPath = '/etc/fazai/fazai.conf';
      let ingestFlag = 'false', metricsFlag = 'false';
      if (fs.existsSync(confPath)) {
        const content = fs.readFileSync(confPath, 'utf8');
        let sec = '';
        content.split(/\r?\n/).forEach(line => {
          const t = line.trim();
          if (!t || t.startsWith('#')) return;
          if (t.startsWith('[') && t.endsWith(']')) { sec = t.slice(1, -1); return; }
          const eq = t.indexOf('=');
          if (eq > 0 && sec === 'telemetry') {
            const key = t.slice(0, eq).trim();
            const val = t.slice(eq + 1).trim().toLowerCase();
            if (key === 'enable_ingest') ingestFlag = val;
            if (key === 'enable_metrics') metricsFlag = val;
          }
        });
      }

      printInfo(`Flags lidas: enable_ingest=${ingestFlag}, enable_metrics=${metricsFlag}`);

      // Testa /ingest
      try {
        const resp = await axios.post(`${API_URL}/ingest`, { hostname: 'smoke', timestamp: new Date().toISOString() });
        if (ingestFlag === 'true') printSuccess('/ingest: OK (200)');
        else printWarning('/ingest: esperado 404 pois enable_ingest != true');
      } catch (e) {
        const status = e?.response?.status;
        if (status === 404 && ingestFlag !== 'true') printSuccess('/ingest: 404 conforme esperado (desabilitado)');
        else printError(`/ingest: falha (${status || e.message})`);
      }

      // Testa /metrics
      try {
        const resp = await axios.get(`${API_URL}/metrics`);
        if (metricsFlag === 'true') printSuccess('/metrics: OK (200)');
        else printWarning('/metrics: esperado 404 pois enable_metrics != true');
      } catch (e) {
        const status = e?.response?.status;
        if (status === 404 && metricsFlag !== 'true') printSuccess('/metrics: 404 conforme esperado (desabilitado)');
        else printError(`/metrics: falha (${status || e.message})`);
      }

      process.exit(0);
    } catch (err) {
      printError(`Erro no smoke test: ${err.message}`);
      process.exit(1);
    }
  }

  // Telemetry toggle command
  if (args[0] === 'telemetry') {
    const enable = args.includes('--enable');
    const disable = args.includes('--disable');
    if (!(enable ^ disable)) {
      console.log(`${colors.fg.cyan}Uso:${colors.reset} fazai telemetry --enable | --disable`);
      process.exit(1);
    }
    const desired = enable ? 'true' : 'false';
    try {
      const confPath = '/etc/fazai/fazai.conf';
      if (!fs.existsSync(confPath)) {
        printError('Config n√£o encontrado: /etc/fazai/fazai.conf');
        process.exit(1);
      }
      // backup r√°pido do conf
      try {
        const bdir = '/var/backups/fazai/config';
        fs.mkdirSync(bdir, { recursive: true });
        const stamp = new Date().toISOString().replace(/[:-]/g,'').replace(/\..+/, '').replace('T','_');
        fs.copyFileSync(confPath, `${bdir}/fazai.conf.${stamp}.bak`);
      } catch (_) {}
      let lines = fs.readFileSync(confPath, 'utf8').split(/\r?\n/);
      let out = [];
      let inSec = false;
      let seenIngest = false;
      let seenMetrics = false;
      let hadSection = false;

      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const t = raw.trim();
        if (t.startsWith('[') && t.endsWith(']')) {
          if (inSec) {
            // leaving [telemetry]; append missing keys
            if (!seenIngest) out.push(`enable_ingest = ${desired}`);
            if (!seenMetrics) out.push(`enable_metrics = ${desired}`);
          }
          inSec = t === '[telemetry]';
          if (inSec) { hadSection = true; seenIngest = false; seenMetrics = false; }
          out.push(raw);
          continue;
        }
        if (inSec) {
          if (t.startsWith('enable_ingest')) { out.push(`enable_ingest = ${desired}`); seenIngest = true; continue; }
          if (t.startsWith('enable_metrics')) { out.push(`enable_metrics = ${desired}`); seenMetrics = true; continue; }
        }
        out.push(raw);
      }
      if (inSec) {
        if (!seenIngest) out.push(`enable_ingest = ${desired}`);
        if (!seenMetrics) out.push(`enable_metrics = ${desired}`);
        inSec = false;
      }
      if (!hadSection) {
        out.push('', '[telemetry]', `enable_ingest = ${desired}`, `enable_metrics = ${desired}`);
      }

      fs.writeFileSync(confPath, out.join('\n'));
      printSuccess(`Flags de telemetria ajustados para ${desired}. Reiniciando servi√ßo...`);

      const { spawnSync } = require('child_process');
      const r = spawnSync('systemctl', ['restart', 'fazai'], { encoding: 'utf8' });
      if (r.status === 0) {
        printSuccess('Servi√ßo fazai reiniciado.');
      } else {
        printWarning('Falha ao reiniciar via systemctl. Reinicie manualmente se necess√°rio.');
        if (r.stderr) console.error(r.stderr);
      }
      process.exit(0);
    } catch (e) {
      printError(`Erro ao ajustar telemetria: ${e.message}`);
      process.exit(1);
    }
  }
  
  if (args[0] === 'limpar-logs' || args[0] === 'clear-logs') {
    clearLogs();
    process.exit(0);
  }
  
  if (args[0] === 'reload') {
    try {
      const result = await reloadModules();
      printSuccess('Plugins e m√≥dulos recarregados com sucesso.');
      process.exit(0);
    } catch (err) {
      printError(err.message);
      process.exit(1);
    }
  }
  
  if (args[0] === 'versao' || args[0] === 'version' || args[0] === '--version' || args[0] === '-v') {
    console.log('FazAI v2.0.0');
    process.exit(0);
  }

  if (['start', 'stop', 'restart', 'status'].includes(args[0])) {
    const ok = systemctlCommand(args[0]);
    process.exit(ok ? 0 : 1);
  }

  // Comandos de cache
  if (args[0] === 'cache') {
    try {
      const response = await axios.get(`${API_URL}/cache`);
      console.log(`\n${colors.bright}${colors.fg.cyan}=== Status do Cache ===${colors.reset}`);
      console.log(`Tamanho atual: ${response.data.size}/${response.data.maxSize} entradas`);
      console.log(`TTL: ${response.data.ttl} segundos`);
      console.log(`Hit rate estimado: ${response.data.size > 0 ? 'Ativo' : 'Vazio'}`);
      console.log(`${colors.bright}${colors.fg.cyan}=====================${colors.reset}\n`);
      process.exit(0);
    } catch (err) {
      printError(`Erro ao verificar cache: ${err.message}`);
      process.exit(1);
    }
  }

  if (args[0] === 'cache-clear') {
    try {
      const response = await axios.delete(`${API_URL}/cache`);
      printSuccess('Cache limpo com sucesso!');
      process.exit(0);
    } catch (err) {
      printError(`Erro ao limpar cache: ${err.message}`);
      process.exit(1);
    }
  }

  // Comando de configura√ß√£o
  if (args[0] === 'config') {

    
    if (!fs.existsSync(config_tool)) {
      printError('Ferramenta de configura√ß√£o n√£o encontrada');
      process.exit(1);
    }

    const { exec } = require('child_process');
    printInfo('Iniciando ferramenta de configura√ß√£o...');
    
    exec(`node ${config_tool}`, (error, stdout, stderr) => {
      if (error) {
        printError(`Erro ao executar ferramenta de configura√ß√£o: ${error.message}`);
        process.exit(1);
      }
      if (stderr) {
        console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
      }
      console.log(`${stdout}`);
      process.exit(0);
    });
  }
  
  // Comandos b√°sicos do sistema que podem ser executados diretamente
  const basicCommands = {
    'kernel': 'uname -r',
    'sistema': 'uname -a',
    'memoria': 'free -h',
    'disco': 'df -h',
    'processos': 'ps aux',
    'rede': 'ip a',
    'data': 'date',
    'uptime': 'uptime',
    'html': 'fazai_html_v1.sh',  // Adiciona comando html como invoca√ß√£o direta
    'web': 'fazai_web.sh',       // Adiciona comando web para interface web

  };
  
  if (basicCommands[args[0]] || args[0] === 'interactive' || args[0] === 'doctor' || args[0] === 'complex') {
    try {
      // Se o comando for 'html', executa o script com par√¢metros
      if (args[0] === 'html') {
        const script_path = '/opt/fazai/tools/fazai_html_v1.sh';
        const data_type = args[1] || 'memoria';
        const chart_type = args[2] || 'bar';
        
        // Executa o script de gera√ß√£o HTML
        const { exec } = require('child_process');
        printInfo(`Gerando visualiza√ß√£o HTML para ${data_type} com gr√°fico ${chart_type}`);
        
        exec(`chmod +x ${script_path} && ${script_path} ${data_type} ${chart_type}`, (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar script HTML: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}Resultado:${colors.reset}\n${stdout}\n`);
          process.exit(0);
        });
      } else if (args[0] === 'web') {
        // Se o comando for 'web', executa o script da interface web
        const script_path = '/opt/fazai/tools/fazai_web.sh';
        
        const { exec } = require('child_process');
        printInfo('Iniciando interface web do FazAI...');
        
        exec(`chmod +x ${script_path} && ${script_path}`, (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar interface web: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}${stdout}${colors.reset}\n`);
          process.exit(0);
        });

      } else if (args[0] === 'interactive') {
        // Novo modo: agente. Use --pty para o shell interativo antigo
        const usePty = args.includes('--pty');
        const WebSocket = require('ws');
        if (usePty) {
          const wsUrl = (process.env.FAZAI_WS_URL || API_URL.replace('http', 'ws')) + '/ws/interactive';
          printInfo(`Conectando WS PTY: ${wsUrl}`);
          const ws = new WebSocket(wsUrl);
          ws.on('open', () => {
            printInfo('Sess√£o PTY aberta. Ctrl+C para sair.');
            if (process.stdin.setRawMode) process.stdin.setRawMode(true);
            process.stdin.resume();
            process.stdin.on('data', (chunk) => {
              if (chunk.length === 1 && chunk[0] === 3) { try { ws.close(); } catch(_) {}; process.exit(0); }
              ws.send(JSON.stringify({ type: 'stdin', data: chunk.toString('utf8') }));
            });
          });
          ws.on('message', (msg) => {
            try { const m = JSON.parse(msg.toString()); if (m.type === 'stdout' && m.data) process.stdout.write(m.data); } catch(_) {}
          });
          ws.on('close', () => { printInfo('Sess√£o encerrada'); process.exit(0); });
          ws.on('error', (e) => { printError(`WS erro: ${e.message}`); process.exit(1); });
          return;
        }
        // Agente
        const wsUrl = (process.env.FAZAI_WS_URL || API_URL.replace('http', 'ws')) + '/ws/agent';
        printInfo(`Conectando WS Agente: ${wsUrl}`);
        const ws = new WebSocket(wsUrl);
        const goal = args.slice(1).join(' ').trim();
        ws.on('open', () => {
          printInfo('Agente iniciado. Digite para enviar instru√ß√µes. Ctrl+C para sair.');
          ws.send(JSON.stringify({ type: 'start', goal }));
          const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
          rl.on('line', (line) => {
            if (line.trim().toLowerCase() === 'exit') { try { ws.close(); } catch(_) {}; process.exit(0); }
            ws.send(JSON.stringify({ type: 'user', text: line }));
          });
        });
        ws.on('message', (msg) => {
          try {
            const m = JSON.parse(msg.toString());
            switch (m.type) {
              case 'state': printInfo(`${m.message || ''} ${m.goal?`goal=${m.goal}`:''}`.trim()); break;
              case 'thought': console.log(`${colors.fg.cyan}Pensamento:${colors.reset} ${m.rationale||''}`); break;
              case 'ask': console.log(`${colors.fg.yellow}Pergunta:${colors.reset} ${m.prompt}`); break;
              case 'confirm_needed': console.log(`${colors.fg.yellow}Confirmar:${colors.reset} ${m.command} (digite: sim/n√£o)`); break;
              case 'step_start': console.log(`${colors.fg.cyan}Executando:${colors.reset} ${m.kind==='shell'?m.command:`tool ${m.tool}`}`); break;
              case 'stdout': process.stdout.write(m.chunk); break;
              case 'stderr': process.stderr.write(`${colors.fg.yellow}${m.chunk}${colors.reset}`); break;
              case 'step_end': console.log(`${colors.fg.cyan}Fim:${colors.reset} ${m.kind} ${m.code!==undefined?('code='+m.code):''}`); break;
              case 'result': console.log(`${colors.fg.green}Resultado:${colors.reset} ${typeof m.output==='string'?m.output:JSON.stringify(m.output,null,2)}`); break;
              case 'error': printError(m.message); break;
              case 'done': printSuccess(m.message||'Conclu√≠do'); process.exit(0);
            }
          } catch(_) {}
        });
        ws.on('close', () => { printInfo('Sess√£o encerrada'); process.exit(0); });
        ws.on('error', (e) => { printError(`WS erro: ${e.message}`); process.exit(1); });
        return;
      } else if (args[0] === 'complex') {
        // Encaminha um objetivo de alto n√≠vel para o daemon executar /complex_flow
        const axios = require('axios');
        const goalIdx = args.indexOf('-g') !== -1 ? args.indexOf('-g') : args.indexOf('--goal');
        const allowWeb = args.includes('-w') || args.includes('--web');
        const goal = goalIdx !== -1 ? args.slice(goalIdx + 1).join(' ') : (rest.join(' ') || question || promptText || '').trim();
        if (!goal) { printError('Uso: fazai complex -g "objetivo" [--web]'); process.exit(2); }
        printInfo(`Executando fluxo complexo: ${goal}${allowWeb?' (web on)':''}`);
        try {
          const res = await axios.post(`${API_URL}/complex_flow`, { goal, allow_web: allowWeb });
          console.log(JSON.stringify(res.data, null, 2));
          process.exit(0);
        } catch (e) {
          printError(`Falha complex_flow: ${e.message}`);
          process.exit(1);
        }
      } else if (args[0] === 'opnsense') {
        // Faz chamada ao endpoint MCP OPNsense
        const axios = require('axios');
        const cmd = args[1] || 'get_system_info';
        const payload = { command: cmd };
        printInfo(`Executando OPNsense MCP: ${cmd}`);
        try {
          const res = await axios.post(`${API_URL}/opnsense`, payload);
          console.log(JSON.stringify(res.data, null, 2));
          process.exit(0);
        } catch (e) {
          printError(`Falha OPNsense: ${e.message}`);
          process.exit(1);
        }
      } else if (args[0] === 'doctor') {
        const axios = require('axios');
        const fs = require('fs');
        let ok = true;
        try { const h = await axios.get(`${API_URL}/health`, { timeout: 3000 }); console.log(`[health] ${h.status}`); } catch (e) { ok=false; console.log(`[health] FAIL ${e.message}`); }
        try { const s = await axios.get(`${API_URL}/status`, { timeout: 3000 }); console.log(`[status] version=${s.data?.version}`); } catch (e) { ok=false; console.log(`[status] FAIL ${e.message}`); }
        const must = ['/opt/fazai/lib/main.js','/opt/fazai/lib/mcp_opnsense.js','/opt/fazai/lib/complex_tasks.js','/opt/fazai/tools/web_search.js','/opt/fazai/tools/fazai_web_frontend.html'];
        must.forEach(p=>console.log(`[file] ${p} ${fs.existsSync(p)?'OK':'MISS'}`));
        const sec = ['/opt/fazai/tools/suricata_setup.js','/opt/fazai/tools/modsecurity_setup.js','/opt/fazai/tools/crowdsec_setup.js','/opt/fazai/tools/spamexperts.js','/opt/fazai/tools/cloudflare.js'];
        sec.forEach(p=>console.log(`[tool] ${p} ${fs.existsSync(p)?'OK':'MISS'}`));
        process.exit(ok?0:1);
      } else {
        // Para outros comandos b√°sicos
        const { exec } = require('child_process');
        printInfo(`Executando comando b√°sico: ${basicCommands[args[0]]}`);
        
        exec(basicCommands[args[0]], (error, stdout, stderr) => {
          if (error) {
            printError(`Erro ao executar comando: ${error.message}`);
            process.exit(1);
          }
          if (stderr) {
            console.error(`${colors.fg.yellow}${stderr}${colors.reset}`);
          }
          console.log(`\n${colors.bright}${colors.fg.yellow}Resultado:${colors.reset}\n${stdout}\n`);
          process.exit(0);
        });
      }
    } catch (err) {
      printError(`Erro ao executar comando b√°sico: ${err.message}`);
      process.exit(1);
    }
  }
  
  if (args[0] === 'check-deps' || args[0] === 'verificar-deps') {
    printInfo("Verificando depend√™ncias do FazAI...");
    
    // Verifica depend√™ncias do Node.js
    try {
      const nodeVersion = process.version;
      printSuccess(`Node.js: ${nodeVersion}`);
      
      // Verifica vers√£o m√≠nima
      const versionNum = nodeVersion.substring(1); // Remove o 'v'
      const major = parseInt(versionNum.split('.')[0], 10);
      
      if (major < 18) {
        printError(`Vers√£o do Node.js (${nodeVersion}) √© menor que a m√≠nima requerida (v18.0.0)`);
      } else {
        printSuccess("Vers√£o do Node.js √© compat√≠vel");
      }
    } catch (err) {
      printError(`Erro ao verificar vers√£o do Node.js: ${err.message}`);
    }
    
    // Verifica arquivo principal
    try {
      if (fs.existsSync('/opt/fazai/lib/main.js')) {
        printSuccess('Arquivo principal: Encontrado em /opt/fazai/lib/main.js');
      } else {
        printError('Arquivo principal: N√£o encontrado');
      }
    } catch (err) {
      printError(`Erro ao verificar arquivo principal: ${err.message}`);
    }
    
    // Verifica depend√™ncias npm
    const dependencies = [
      { name: 'axios', version: '0.27.2' },
      { name: 'express', version: '4.18.1' },
      { name: 'winston', version: '3.8.1' },
      { name: 'ffi-napi-v22', version: '0.0.1' }
    ];
    
    dependencies.forEach(dep => {
      try {
        const depPackage = require(`${dep.name}/package.json`);
        printSuccess(`${dep.name}: ${depPackage.version} (requerido: ${dep.version})`);
      } catch (err) {
        printError(`${dep.name}: N√£o encontrado ou n√£o pode ser carregado`);
      }
    });
    
    // Verifica diret√≥rios e arquivos
    const paths = [
      { path: '/opt/fazai', type: 'dir', desc: 'Diret√≥rio de instala√ß√£o' },
      { path: '/opt/fazai/lib/main.js', type: 'file', desc: 'Arquivo principal' },
      { path: '/opt/fazai/tools', type: 'dir', desc: 'Diret√≥rio de ferramentas' },
      { path: '/opt/fazai/mods', type: 'dir', desc: 'Diret√≥rio de m√≥dulos' },
      { path: '/etc/fazai', type: 'dir', desc: 'Diret√≥rio de configura√ß√£o' },
      { path: '/etc/fazai/fazai.conf', type: 'file', desc: 'Arquivo de configura√ß√£o' },
      { path: '/var/log/fazai/fazai.log', type: 'file', desc: 'Arquivo de log', optional: true },
      { path: '/var/lib/fazai', type: 'dir', desc: 'Diret√≥rio de dados', optional: true }
    ];
    
    paths.forEach(item => {
      try {
        const exists = fs.existsSync(item.path);
        if (exists) {
          const stats = fs.statSync(item.path);
          if ((item.type === 'dir' && stats.isDirectory()) || 
              (item.type === 'file' && stats.isFile())) {
            printSuccess(`${item.desc} (${item.path}): OK`);
          } else {
            printError(`${item.desc} (${item.path}): Tipo incorreto`);
          }
        } else if (item.optional) {
          printInfo(`${item.desc} (${item.path}): N√£o encontrado (opcional)`);
        } else {
          printError(`${item.desc} (${item.path}): N√£o encontrado`);
        }
      } catch (err) {
        printError(`Erro ao verificar ${item.path}: ${err.message}`);
      }
    });
    
    // Verifica√ß√£o do gemma_oneshot e bin√°rio real
    try {
      const wrapperPath = '/opt/fazai/bin/gemma_oneshot';
      if (fs.existsSync(wrapperPath)) {
        const st = fs.statSync(wrapperPath);
        if ((st.mode & 0o111) !== 0) {
          printSuccess(`Wrapper gemma_oneshot: OK (${wrapperPath})`);
        } else {
          printWarning(`Wrapper gemma_oneshot existe mas pode n√£o ser execut√°vel: ${wrapperPath}`);
        }
      } else {
        printWarning('Wrapper gemma_oneshot: n√£o encontrado em /opt/fazai/bin');
      }

      const candidates = [
        '/opt/fazai/bin/gemma_oneshot.real',
        '/usr/local/bin/gemma_oneshot',
        '/usr/bin/gemma_oneshot',
        '/root/gemma.cpp/build/gemma_oneshot'
      ];
      const found = candidates.find(p => { try { return fs.existsSync(p) && (fs.statSync(p).mode & 0o111) !== 0; } catch { return false; } });
      if (found) {
        printSuccess(`Bin√°rio real do Gemma: encontrado (${found})`);
      } else {
        printWarning('Bin√°rio real do Gemma n√£o encontrado. Compile/instale gemma.cpp e disponibilize gemma_oneshot.');
        console.log('  Candidatos verificados:');
        candidates.forEach(c => console.log(`   - ${c}`));
        console.log('\nSugest√£o:');
        console.log('  1) Compilar gemma.cpp e instalar o bin√°rio:');
        console.log('     git clone https://github.com/google/gemma.cpp && cd gemma.cpp');
        console.log('     cmake -S . -B build && cmake --build build -j$(nproc)');
        console.log('     sudo install -m 0755 build/gemma_oneshot /usr/local/bin/gemma_oneshot');
        console.log('  2) Ou aponte o caminho real em /opt/fazai/bin/gemma_oneshot (wrapper procura candidatos listados).');
      }

      // Leitura simples do fazai.conf para validar [gemma_cpp] e [telemetry]
      const confPath = '/etc/fazai/fazai.conf';
      if (fs.existsSync(confPath)) {
        const content = fs.readFileSync(confPath, 'utf8');
        let sec = '';
        const gemma = {};
        const telemetry = {};
        content.split(/\r?\n/).forEach(line => {
          const t = line.trim();
          if (!t || t.startsWith('#')) return;
          if (t.startsWith('[') && t.endsWith(']')) { sec = t.slice(1, -1); return; }
          const eq = t.indexOf('=');
          if (eq > 0) {
            const key = t.slice(0, eq).trim();
            const val = t.slice(eq + 1).trim();
            if (sec === 'gemma_cpp') gemma[key] = val;
            if (sec === 'telemetry') telemetry[key] = val;
          }
        });
        if (gemma.weights) {
          if (fs.existsSync(gemma.weights)) {
            printSuccess(`[gemma_cpp].weights: OK (${gemma.weights})`);
          } else {
            printWarning(`[gemma_cpp].weights: caminho n√£o encontrado (${gemma.weights})`);
            console.log('\nSugest√£o:');
            console.log('  ‚Ä¢ Se usar arquivo √∫nico (.sbs), baixe/coloque em /opt/fazai/models/gemma/2.0-2b-it-sfp.sbs');
            console.log('  ‚Ä¢ Execute: sudo /opt/fazai/tools/gemma_bootstrap.sh (aceitar EULA)');
            console.log('  ‚Ä¢ Ajuste [gemma_cpp].weights em /etc/fazai/fazai.conf');
          }
        } else {
          printWarning('[gemma_cpp].weights: n√£o definido em fazai.conf');
          console.log('\nSugest√£o: adicionar no /etc/fazai/fazai.conf:');
          console.log('[gemma_cpp]');
          console.log('weights = /opt/fazai/models/gemma/2.0-2b-it-sfp.sbs');
        }
        if (gemma.default_model) {
          printSuccess(`[gemma_cpp].default_model: ${gemma.default_model}`);
        } else {
          printWarning('[gemma_cpp].default_model: n√£o definido em fazai.conf');
          console.log('\nSugest√£o: adicionar no /etc/fazai/fazai.conf:');
          console.log('[gemma_cpp]');
          console.log('default_model = gemma2-2b-it');
        }

        const ingestFlag = (telemetry.enable_ingest || '').toLowerCase();
        const metricsFlag = (telemetry.enable_metrics || '').toLowerCase();
        if (ingestFlag === 'true' || ingestFlag === 'false') {
          printSuccess(`[telemetry].enable_ingest: ${ingestFlag}`);
        } else {
          printWarning('[telemetry].enable_ingest: n√£o definido (padr√£o: desabilitado)');
          console.log('\nSugest√£o: para habilitar ingest√£o, adicione no /etc/fazai/fazai.conf:');
          console.log('[telemetry]');
          console.log('enable_ingest = true');
        }
        if (metricsFlag === 'true' || metricsFlag === 'false') {
          printSuccess(`[telemetry].enable_metrics: ${metricsFlag}`);
        } else {
          printWarning('[telemetry].enable_metrics: n√£o definido (padr√£o: desabilitado)');
          console.log('\nSugest√£o: para habilitar m√©tricas, adicione no /etc/fazai/fazai.conf:');
          console.log('[telemetry]');
          console.log('enable_metrics = true');
        }
      } else {
        printWarning('Config n√£o encontrado: /etc/fazai/fazai.conf');
      }
    } catch (err) {
      printError(`Erro na verifica√ß√£o de Gemma/telemetria: ${err.message}`);
    }

    // Verifica servi√ßo systemd
    try {
      const systemctl = spawn('systemctl', ['status', 'fazai']);
      let output = '';
      
      systemctl.stdout.on('data', (data) => {
        output += data.toString();
      });
      
      systemctl.stderr.on('data', (data) => {
        output += data.toString();
      });
      
      systemctl.on('close', (code) => {
        if (code === 0) {
          if (output.includes('Active: active (running)')) {
            printSuccess('Servi√ßo systemd: Ativo e em execu√ß√£o');
          } else if (output.includes('Active: inactive')) {
            printError('Servi√ßo systemd: Inativo');
          } else {
            printWarning('Servi√ßo systemd: Status desconhecido');
            console.log(output);
          }
        } else {
          printError(`Servi√ßo systemd: N√£o encontrado ou erro ao verificar (c√≥digo ${code})`);
        }
      });
    } catch (err) {
      printError(`Erro ao verificar servi√ßo systemd: ${err.message}`);
    }

    // Verifica DOCLER e Qdrant
    try {
      const svc = spawn('systemctl', ['status', 'fazai-docler']);
      let out = '';
      svc.stdout.on('data', d => out += d.toString());
      svc.stderr.on('data', d => out += d.toString());
      svc.on('close', (code) => {
        if (code === 0 && out.includes('active (running)')) {
          printSuccess('Servi√ßo fazai-docler: Ativo (3220/3221)');
        } else {
          printWarning('Servi√ßo fazai-docler: Inativo ou ausente');
        }
      });
    } catch (_) {}

    try {
      const svc = spawn('systemctl', ['status', 'fazai-qdrant']);
      let out = '';
      svc.stdout.on('data', d => out += d.toString());
      svc.stderr.on('data', d => out += d.toString());
      svc.on('close', async (code) => {
        if (code === 0 && out.includes('active (exited)')) {
          // oneshot RemainAfterExit: container deve estar rodando
          try {
            const resp = await axios.get('http://127.0.0.1:6333/collections');
            if (resp.status === 200) printSuccess('Qdrant: Dispon√≠vel em 127.0.0.1:6333');
            else printWarning('Qdrant: Resposta inesperada');
          } catch (e) {
            printWarning(`Qdrant: n√£o responde (${e.message})`);
          }
        } else {
          printWarning('Servi√ßo fazai-qdrant: Inativo ou ausente');
        }
      });
    } catch (_) {}

    // Teste HTTP das portas Docler 3220/3221
    try {
      const res1 = await axios.get('http://127.0.0.1:3220', { timeout: 2000 });
      if (res1.status === 200) printSuccess('Docler porta 3220: OK'); else printWarning('Docler 3220: resposta inesperada');
    } catch (e) {
      printWarning(`Docler porta 3220: indispon√≠vel (${e.message})`);
    }
    try {
      const res2 = await axios.get('http://127.0.0.1:3221', { timeout: 2000 });
      if (res2.status === 200) printSuccess('Docler porta 3221: OK'); else printWarning('Docler 3221: resposta inesperada');
    } catch (e) {
      printWarning(`Docler porta 3221: indispon√≠vel (${e.message})`);
    }

    // Teste Qdrant: criar cole√ß√£o tempor√°ria, upsert e search
    try {
      const base = 'http://127.0.0.1:6333';
      const cname = `fazai_check_${Date.now()}`;
      await axios.put(`${base}/collections/${cname}`, { vectors: { size: 4, distance: 'Cosine' } }, { timeout: 5000 });
      await axios.put(`${base}/collections/${cname}/points`, { points: [{ id: 1, vector: [1,0,0,0], payload: { hello: 'world' } }] }, { timeout: 5000 });
      const sr = await axios.post(`${base}/collections/${cname}/points/search`, { vector: [1,0,0,0], limit: 1 }, { timeout: 5000 });
      const ok = Array.isArray(sr.data?.result) && sr.data.result.length > 0;
      if (ok) printSuccess('Qdrant teste (create/upsert/search): OK'); else printWarning('Qdrant teste: sem resultados');
      await axios.delete(`${base}/collections/${cname}`, { timeout: 5000 });
    } catch (e) {
      printWarning(`Qdrant teste: falhou (${e.message})`);
    }

    // Depend√™ncias obrigat√≥rias
    const reqs = [
      { name: 'express', type: 'node' },
      { name: 'winston', type: 'node' },
      { name: 'axios', type: 'node' },
      { name: 'multer', type: 'node' },
    ];
    reqs.forEach(r => { try { require(`${r.name}`); printSuccess(`Depend√™ncia Node: ${r.name}`); } catch { printWarning(`Depend√™ncia Node ausente: ${r.name}`); } });
    if (require('fs').existsSync('/opt/fazai/web/package.json')) {
      try { require('/opt/fazai/web/node_modules/ws'); printSuccess('Web dep: ws'); } catch { printWarning('Web dep ausente: ws'); }
      try { require('/opt/fazai/web/node_modules/express'); printSuccess('Web dep: express'); } catch { printWarning('Web dep ausente: express'); }
    }
    // Container runtime
    const hasDocker = (()=>{ try { return !!require('child_process').spawnSync('docker',['--version']).status===0; } catch { return false; }})();
    const hasPodman = (()=>{ try { return !!require('child_process').spawnSync('podman',['--version']).status===0; } catch { return false; }})();
    if (hasDocker) printSuccess('Docker: dispon√≠vel'); else printInfo('Docker: n√£o encontrado');
    if (hasPodman) printSuccess('Podman: dispon√≠vel'); else printInfo('Podman: n√£o encontrado');
    // Prometheus/Grafana HTTP checks
    try { const r = await axios.get('http://127.0.0.1:9090/-/healthy', { timeout: 2000 }); if (r.status===200) printSuccess('Prometheus: OK'); else printWarning('Prometheus: resposta inesperada'); } catch(e){ printWarning(`Prometheus: indispon√≠vel (${e.message})`); }
    try { const r = await axios.get('http://127.0.0.1:3000/api/health', { timeout: 2000 }); if (r.status===200 && r.data?.database==='ok') printSuccess('Grafana: OK'); else printWarning('Grafana: resposta inesperada'); } catch(e){ printWarning(`Grafana: indispon√≠vel (${e.message})`); }

    // OPNsense multiserver checks via daemon
    try {
      const list = await axios.get(`${API_URL}/opn/list`, { timeout: 5000 }).then(r => r.data.items || []);
      if (Array.isArray(list) && list.length > 0) {
        printInfo(`OPNsense cadastrados: ${list.length}`);
        for (const fw of list) {
          try {
            const t0 = Date.now();
            const hr = await axios.get(`${API_URL}/opn/${fw.id}/health`, { timeout: 8000 });
            const lat = Date.now() - t0;
            if (hr.data?.success) printSuccess(`OPNsense ${fw.name} (${fw.id}): OK (${lat}ms)`);
            else printWarning(`OPNsense ${fw.name}: falha`);
          } catch (e) {
            printWarning(`OPNsense ${fw.name}: erro de health (${e.message})`);
          }
        }
      } else {
        printInfo('Nenhum OPNsense cadastrado no registro');
      }
    } catch (e) {
      printInfo('Registro OPNsense: endpoint indispon√≠vel');
    }
    
    // Verifica gera√ß√£o de logs
    try {
      const logFile = '/var/log/fazai/fazai.log';
      const errFile = '/var/log/fazai/fazai-error.log';
      const outFile = '/var/log/fazai/stdout.log';
      const seFile = '/var/log/fazai/stderr.log';
      const sizeOrZero = (p) => { try { return fs.existsSync(p) ? fs.statSync(p).size : 0; } catch { return 0; } };
      const before = sizeOrZero(logFile);
      // Dispara um endpoint que loga
      try { await axios.get(`${API_URL}/status`); } catch (_) {}
      const after = sizeOrZero(logFile);
      if (fs.existsSync(logFile)) {
        if (after >= before) {
          printSuccess(`${logFile}: OK (${after} bytes)`);
        } else {
          printWarning(`${logFile}: presente mas sem crescimento detectado`);
        }
      } else {
        printWarning(`${logFile}: n√£o encontrado`);
      }
      // Arquivos de sa√≠da do systemd
      if (fs.existsSync(outFile)) printSuccess(`${outFile}: OK (${sizeOrZero(outFile)} bytes)`); else printInfo(`${outFile}: (opcional) n√£o encontrado`);
      if (fs.existsSync(seFile)) printSuccess(`${seFile}: OK (${sizeOrZero(seFile)} bytes)`); else printInfo(`${seFile}: (opcional) n√£o encontrado`);
      if (fs.existsSync(errFile)) printSuccess(`${errFile}: OK (${sizeOrZero(errFile)} bytes)`);
    } catch (err) {
      printWarning(`Falha ao verificar logs: ${err.message}`);
    }
    
    process.exit(0);
  }
  
  // Modo MCPS - planejamento passo a passo
  if (args[0] === 'mcps') {
    const mcpsCommand = args.slice(1).join(' ');
    if (!mcpsCommand) {
      printError('Nenhum comando fornecido para o modo MCPS.');
      process.exit(1);
    }

    try {
      printInfo(`Enviando comando MCPS${streamEnabled ? ' (stream)' : ''}: "${mcpsCommand}"`);
      if (streamEnabled) {
        await streamToConsole({ command: mcpsCommand, mcps: true });
        process.exit(0);
      }
      const result = await sendCommandMcps(mcpsCommand);

      if (result.success) {
        printSuccess('MCPS executado com sucesso.');

        if (result.steps) {
          result.steps.forEach((step, idx) => {
            console.log(`\n${colors.bright}${colors.fg.yellow}Passo ${idx + 1}:${colors.reset} ${step.command}\n${step.output}\n`);
          });
        }
      } else {
        printError(`Falha no MCPS: ${result.error || 'Erro desconhecido'}`);
      }
    } catch (err) {
      printError(err.message);
      process.exit(1);
    }

    process.exit(0);
  }

  // Verificar se √© o subcomando agent
  if (args[0] === 'agent') {
    if (args.length < 2) {
      printError('Objetivo √© obrigat√≥rio para o comando agent');
      console.log(`${colors.fg.cyan}Uso: fazai agent "seu objetivo aqui"${colors.reset}`);
      process.exit(1);
    }
    
    const objective = args.slice(1).join(' ');
    await runAgent(objective);
    process.exit(0);
  }

  // Verificar se √© o subcomando relay
  if (args[0] === 'relay') {
    if (args.length < 2) {
      printError('Comando √© obrigat√≥rio para o subcomando relay');
      console.log(`${colors.fg.cyan}Uso: fazai relay <comando> [args...]${colors.reset}`);
      process.exit(1);
    }
    
    const command = args[1];
    const commandArgs = args.slice(2);
    await runRelayCommand(command, commandArgs);
    process.exit(0);
  }

  // Subcomando OPNsense (linguagem natural)
  if (args[0] === 'opn') {
    const phrase = args.slice(1).join(' ').trim();
    if (!phrase) {
      printError('Forne√ßa a frase, ex: fazai opn "listar interfaces do fw-01"');
      process.exit(1);
    }
    try {
      const r = await axios.post(`${API_URL}/opn/nl`, { query: phrase });
      console.log(JSON.stringify(r.data, null, 2));
      process.exit(0);
    } catch (e) {
      printError(`Erro no comando OPNsense: ${e.response?.data?.error || e.message}`);
      process.exit(1);
    }
  }

  // Verificar se √© o subcomando docler
  if (args[0] === 'docler') {
    if (args.length < 2) {
      printError('Comando √© obrigat√≥rio para o subcomando docler');
      console.log(`${colors.fg.cyan}Uso: fazai docler <comando> [args...]${colors.reset}`);
      process.exit(1);
    }
    
    const command = args[1];
    const commandArgs = args.slice(2);
    await runDoclerCommand(command, commandArgs);
    process.exit(0);
  }

  // Comando normal para o FazAI
  const command = args.join(' ');
  
  try {
    printInfo(`Enviando comando${streamEnabled ? ' (stream)' : ''}${questionMode ? ' (question)' : ''}: "${command}"`);
    if (streamEnabled) {
      await streamToConsole({ command, question: questionMode });
      process.exit(0);
    }
    if (rawArgs.includes('-w') || rawArgs.includes('--web')) {
      // For√ßa pesquisa web
      const axios = require('axios');
      const res = await axios.post(`${API_URL}/search`, { query: command });
      if (res.data && res.data.success) {
        const first = res.data.first;
        if (first && first.url) {
          console.log(first.url);
        } else {
          console.log(JSON.stringify(res.data.results.slice(0, 3), null, 2));
        }
        process.exit(0);
      } else {
        printError(`Falha na pesquisa web: ${res.data && res.data.error ? res.data.error : 'erro'}`);
        process.exit(1);
      }
    }
    const result = await sendCommand(questionMode ? { question: true, command } : command);
    
    if (result.success) {
      if (result.type === 'question' && result.answer) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Resposta:${colors.reset}\n${result.answer}\n`);
        printSuccess('Pergunta respondida.');
      } else {
        printSuccess('Comando executado com sucesso.');
        if (result.interpretation) {
          console.log(`\n${colors.bright}${colors.fg.yellow}Interpreta√ß√£o:${colors.reset} ${result.interpretation}\n`);
        }
        if (result.result) {
          console.log(`\n${colors.bright}${colors.fg.yellow}Resultado:${colors.reset}\n${result.result}\n`);
        }
      }
    } else {
      if (result.interpretation) {
        console.log(`\n${colors.bright}${colors.fg.yellow}Interpreta√ß√£o:${colors.reset} ${result.interpretation}\n`);
      }
      
      printError(`Falha ao executar comando: ${result.error || 'Erro desconhecido'}`);
      
      if (result.details) {
        printInfo(`Detalhes t√©cnicos: ${result.details}`);
      }
      
      // Sugest√µes para problemas comuns
      if (result.error && result.error.includes('API')) {
        printInfo('Sugest√£o: Verifique se as chaves de API est√£o configuradas corretamente no arquivo .env ou /etc/fazai/fazai.conf');
      } else if (result.error && (result.error.includes('conectar') || result.error.includes('conex√£o'))) {
        printInfo('Sugest√£o: Verifique se o daemon est√° em execu√ß√£o com "systemctl status fazai" ou inicie-o com "systemctl start fazai"');
      }
    }
  } catch (err) {
    printError(err.message);
    
    // Sugest√µes para erros comuns
    if (err.message.includes('conectar') || err.message.includes('ECONNREFUSED')) {
      printInfo('Sugest√£o: O daemon FazAI parece n√£o estar em execu√ß√£o. Tente iniciar o servi√ßo com:');
      console.log(`${colors.fg.cyan}  sudo systemctl start fazai${colors.reset}`);
      printInfo('Para verificar o status do servi√ßo, use:');
      console.log(`${colors.fg.cyan}  sudo systemctl status fazai${colors.reset}`);
    } else if (err.message.includes('timeout')) {
      printInfo('Sugest√£o: A conex√£o com o daemon expirou. Isso pode ocorrer se:');
      console.log(`${colors.fg.cyan}  1. O daemon est√° sobrecarregado${colors.reset}`);
      console.log(`${colors.fg.cyan}  2. A conex√£o com o provedor de IA est√° lenta${colors.reset}`);
      console.log(`${colors.fg.cyan}  3. O comando √© muito complexo e est√° demorando para ser processado${colors.reset}`);
    }
    
    process.exit(1);
  }
}

// Executa a fun√ß√£o principal
main().catch(err => {
  printError(`Erro n√£o tratado: ${err.message}`);
  process.exit(1);
});
