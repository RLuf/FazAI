// FazAI Tool: auto_tool
// Gera e instala uma ferramenta sob demanda a partir de uma especificação
// em linguagem natural ou código fornecido, recarrega o daemon e retorna
// metadados. Por padrão gera ferramentas Node.js em /opt/fazai/tools.

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const axios = require('axios');

exports.info = {
  name: 'auto_tool',
  description: 'Gera e instala ferramentas (plugins) dinamicamente a partir de especificação em linguagem natural ou código fornecido',
  interactive: false
};

function writeFileAtomic(filePath, content) {
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
  const tmp = filePath + '.tmp.' + Date.now();
  fs.writeFileSync(tmp, content, 'utf8');
  fs.renameSync(tmp, filePath);
}

function extractCodeBlocks(text) {
  // Extrai o primeiro bloco ```[lang]\n...``` se existir; senão, retorna texto inteiro
  const m = text.match(/```[a-zA-Z0-9_-]*\n([\s\S]*?)```/);
  if (m && m[1]) return m[1].trim();
  return text.trim();
}

function defaultJsTemplate(toolName) {
  return `// Generated by auto_tool\nconst { exec } = require('child_process');\nexports.info = { name: '${toolName}', description: 'Generated tool', interactive: false };\nexports.run = async function(params = {}) {\n  return { success: true, echo: params };\n};\n`;
}

async function generateCodeFromLLM(task, language = 'js', toolName = 'generated_tool') {
  const apiUrl = process.env.FAZAI_API_URL || 'http://localhost:3120';
  const system = `Você vai gerar o código de uma ferramenta do FazAI (plugin Node.js).\nRequisitos:\n- exportar 'info' (name, description, interactive) e 'run(params)' Promise.\n- Sem explicações; responda APENAS com um bloco de código completo e funcional.\n- Linguagem: ${language}.\n- Nome da ferramenta: ${toolName}.`;
  const user = `Especifique e gere a ferramenta para: ${task}\nFormato: bloco de código único.`;
  const payload = { command: `${system}\n\n${user}`, question: true };
  const resp = await axios.post(`${apiUrl}/command`, payload, { timeout: 180000 });
  const text = (resp.data && (resp.data.answer || resp.data.result || '')) || '';
  return extractCodeBlocks(text) || defaultJsTemplate(toolName);
}

exports.run = async function(params = {}) {
  const toolsDir = '/opt/fazai/tools';
  const toolName = (params.tool_name || 'generated_tool').replace(/[^a-z0-9_\-]/gi, '_');
  const language = (params.language || 'js').toLowerCase();
  const fileExt = language === 'sh' ? 'sh' : language === 'py' ? 'py' : 'js';
  const filePath = path.join(toolsDir, `${toolName}.${fileExt}`);

  let code = params.code || '';
  if (!code) {
    if (!params.task) throw new Error('Parâmetro ausente: task (descrição em linguagem natural)');
    code = await generateCodeFromLLM(params.task, 'js', toolName);
  }

  // Se for JS e não contiver exports, envolve num template básico
  if (fileExt === 'js' && !/exports\.run\s*=/.test(code)) {
    const wrapped = defaultJsTemplate(toolName);
    // tenta inserir o corpo dentro de run() se possível
    code = wrapped;
  }

  writeFileAtomic(filePath, code);
  try { execSync(`chmod +x "${filePath}"`); } catch (_) {}

  // Solicita recarregamento do daemon
  try { await axios.post('http://localhost:3120/reload'); } catch (_) {}

  return {
    success: true,
    tool_name: toolName,
    path: filePath,
    language: fileExt,
    bytes_written: Buffer.byteLength(code, 'utf8')
  };
};
